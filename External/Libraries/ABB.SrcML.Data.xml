<?xml version="1.0"?>
<doc>
    <assembly>
        <name>ABB.SrcML.Data</name>
    </assembly>
    <members>
        <member name="T:ABB.SrcML.Data.AbstractCodeParser">
            <summary>
            <para>AbstractCodeParser is used to parse SrcML files and extract useful info from the
            elements. Implementations of this class provide language-specific functions to extract
            useful data from the class.</para> <para>The entry point for this class is the
            <see cref="M:ABB.SrcML.Data.AbstractCodeParser.ParseFileUnit(System.Xml.Linq.XElement)"/> method.</para>
            </summary>
        </member>
        <member name="M:ABB.SrcML.Data.AbstractCodeParser.#ctor">
            <summary>
            Creates a new abstract code parser object. Should only be called by child classes.
            </summary>
        </member>
        <member name="M:ABB.SrcML.Data.AbstractCodeParser.CreateResolvableUse(System.Xml.Linq.XElement,ABB.SrcML.Data.ParserContext)">
            <summary>
            Creates a resolvable use from an expression
            </summary>
            <param name="element">The element to parse</param>
            <param name="context">The parser context</param>
            <returns>A resolvable use object</returns>
        </member>
        <member name="M:ABB.SrcML.Data.AbstractCodeParser.CreateVariableUse(System.Xml.Linq.XElement,ABB.SrcML.Data.ParserContext)">
            <summary>
            Creates a variable use from the given element. Must be a
            <see cref="F:ABB.SrcML.SRC.Expression"/>, <see cref="F:ABB.SrcML.SRC.Name"/>, or
            <see cref="F:ABB.SrcML.SRC.ExpressionStatement"/>
            </summary>
            <param name="element">The element to parse</param>
            <param name="context">The parser context</param>
            <returns>A variable use object</returns>
        </member>
        <member name="M:ABB.SrcML.Data.AbstractCodeParser.GetAliasElementsForFile(System.Xml.Linq.XElement)">
            <summary>
            Gets the alias elements for this file. This only returns the aliases at the root of the
            file
            </summary>
            <param name="fileUnit">The file unit to get the aliases from</param>
            <returns>The alias elements</returns>
        </member>
        <member name="M:ABB.SrcML.Data.AbstractCodeParser.GetParametersFromMethodElement(System.Xml.Linq.XElement)">
            <summary>
            Gets all of the parameters for this method. It finds the variable declarations in
            parameter list.
            </summary>
            <param name="method">The method container</param>
            <returns>An enumerable of all the declaration XElements.</returns>
        </member>
        <member name="M:ABB.SrcML.Data.AbstractCodeParser.GetParentTypeUseElements(System.Xml.Linq.XElement)">
            <summary>
            Gets the type use elements from a <see cref="P:ABB.SrcML.Data.AbstractCodeParser.TypeElementNames">type definition
            element</see>
            </summary>
            <param name="typeElement">The type element. Must belong to see
            cref="TypeElementNames"/&gt;</param>
            <returns>An enumerable of type uses that represent parent types</returns>
        </member>
        <member name="M:ABB.SrcML.Data.AbstractCodeParser.ParseAliasElement(System.Xml.Linq.XElement,ABB.SrcML.Data.ParserContext)">
            <summary>
            Creates an <see cref="T:ABB.SrcML.Data.Alias"/> object from a using import (such as using in C++ and C#
            and import in Java).
            </summary>
            <param name="aliasStatement">The statement to parse. Should be of type see
            cref="AliasElementName"/&gt;</param>
            <param name="context">The context to place the resulting alias in</param>
            <returns>a new alias object that represents this alias statement</returns>
        </member>
        <member name="M:ABB.SrcML.Data.AbstractCodeParser.ParseCallElement(System.Xml.Linq.XElement,ABB.SrcML.Data.ParserContext)">
            <summary>
            Creates a method call object
            </summary>
            <param name="callElement">The XML element to parse</param>
            <param name="context">The parser context</param>
            <returns>A method call for
            <paramref name="callElement"/></returns>
        </member>
        <member name="M:ABB.SrcML.Data.AbstractCodeParser.ParseContainerElement(System.Xml.Linq.XElement,ABB.SrcML.Data.ParserContext)">
            <summary>
            Creates a <see cref="T:ABB.SrcML.Data.Scope"/> object for
            <paramref name="element"/>and pushes it onto
            <paramref name="context"/></summary>
            <param name="element">The element to parse</param>
            <param name="context">the context to place the resulting scope on</param>
        </member>
        <member name="M:ABB.SrcML.Data.AbstractCodeParser.ParseDeclarationElement(System.Xml.Linq.XElement,ABB.SrcML.Data.ParserContext)">
            <summary>
            Creates variable declaration objects from the given declaration element
            </summary>
            <param name="declarationElement">The variable declaration to parse. Must belong to see
            cref="VariableDeclarationElementNames"/></param>
            <param name="context">The parser context</param>
            <returns>One variable declaration object for each declaration in
            <paramref name="declarationElement"/></returns>
        </member>
        <member name="M:ABB.SrcML.Data.AbstractCodeParser.ParseElement(System.Xml.Linq.XElement,ABB.SrcML.Data.ParserContext)">
            <summary>
            This is the main function that parses srcML nodes. It selects the appropriate parse
            element to call and then adds declarations, method calls, and children to it
            </summary>
            <param name="element">The element to parse</param>
            <param name="context">The parser context</param>
            <returns>The scope representing
            <paramref name="element"/></returns>
        </member>
        <member name="M:ABB.SrcML.Data.AbstractCodeParser.ParseElement_Concurrent(System.Xml.Linq.XElement,ABB.SrcML.Data.ParserContext)">
            <summary>
            This is the main function that parses srcML nodes. It selects the appropriate parse
            element to call and then adds declarations, method calls, and children to it
            </summary>
            <param name="element">The element to parse</param>
            <param name="context">The parser context</param>
            <returns>The scope representing
            <paramref name="element"/></returns>
        </member>
        <member name="M:ABB.SrcML.Data.AbstractCodeParser.ParseFileUnit(System.Xml.Linq.XElement)">
            <summary>
            Parses a file unit and returns a <see cref="P:ABB.SrcML.Data.NamespaceDefinition.IsGlobal">global</see>
            <see cref="T:ABB.SrcML.Data.NamespaceDefinition">namespace definition</see> object
            </summary>
            <param name="fileUnit">The file unit to parse</param>
            <returns>a global namespace definition for
            <paramref name="fileUnit"/></returns>
        </member>
        <member name="M:ABB.SrcML.Data.AbstractCodeParser.ParseFileUnit_Concurrent(System.Xml.Linq.XElement)">
            <summary>
            Concurrently parses a file unit and returns a
            <see cref="P:ABB.SrcML.Data.NamespaceDefinition.IsGlobal">global</see>
            <see cref="T:ABB.SrcML.Data.NamespaceDefinition">namespace definition</see> object
            </summary>
            <param name="fileUnit">The file unit to parse</param>
            <returns>a global namespace definition for
            <paramref name="fileUnit"/></returns>
        </member>
        <member name="M:ABB.SrcML.Data.AbstractCodeParser.ParseMethodElement(System.Xml.Linq.XElement,ABB.SrcML.Data.ParserContext)">
            <summary>
            Creates a <see cref="T:ABB.SrcML.Data.MethodDefinition"/> object for
            <paramref name="methodElement"/>and pushes it onto
            <paramref name="context"/></summary>
            <param name="methodElement">The element to parse</param>
            <param name="context">The context to place the resulting method definition in</param>
        </member>
        <member name="M:ABB.SrcML.Data.AbstractCodeParser.ParseMethodParameterElement(System.Xml.Linq.XElement,ABB.SrcML.Data.ParserContext)">
            <summary>
            Generates a parameter declaration for the given declaration
            </summary>
            <param name="declElement">The declaration XElement from within the parameter element.
            Must be a <see cref="F:ABB.SrcML.SRC.Declaration"/> or see
            cref="ABB.SrcML.SRC.FunctionDeclaration"/&gt;</param>
            <param name="context">the parser context</param>
            <returns>A parameter declaration object</returns>
        </member>
        <member name="M:ABB.SrcML.Data.AbstractCodeParser.ParseNamedScopeUsePrefix(System.Xml.Linq.XElement,ABB.SrcML.Data.ParserContext)">
            <summary>
            Creates a named scope use element
            </summary>
            <param name="nameElement">The name element to parse</param>
            <param name="context">The parser context</param>
            <returns>A named scope use for this element</returns>
        </member>
        <member name="M:ABB.SrcML.Data.AbstractCodeParser.ParseNamespaceElement(System.Xml.Linq.XElement,ABB.SrcML.Data.ParserContext)">
            <summary>
            Creates a <see cref="T:ABB.SrcML.Data.NamespaceDefinition"/> object for
            <paramref name="namespaceElement"/>and pushes it onto
            <paramref name="context"/></summary>
            <param name="namespaceElement">The element to parse</param>
            <param name="context">The context to place the resulting namespace definition in</param>
        </member>
        <member name="M:ABB.SrcML.Data.AbstractCodeParser.ParseTypeElement(System.Xml.Linq.XElement,ABB.SrcML.Data.ParserContext)">
            <summary>
            Parses a type element and pushes a it onto the
            <paramref name="context"/>.
            </summary>
            <param name="typeElement">the type element to parse</param>
            <param name="context">The parser context</param>
        </member>
        <member name="M:ABB.SrcML.Data.AbstractCodeParser.ParseTypeUseElement(System.Xml.Linq.XElement,ABB.SrcML.Data.ParserContext)">
            <summary>
            Creates a type use element
            </summary>
            <param name="typeUseElement">the element to parse. Must be of a
            <see cref="F:ABB.SrcML.SRC.Type"/> or see cref="ABB.SrcML.SRC.Name"/&gt;</param>
            <param name="context">the parser context</param>
            <returns>A Type Use object</returns>
        </member>
        <member name="M:ABB.SrcML.Data.AbstractCodeParser.ParseUnitElement(System.Xml.Linq.XElement,ABB.SrcML.Data.ParserContext)">
            <summary>
            Creates a global <see cref="T:ABB.SrcML.Data.NamespaceDefinition"/> object for
            <paramref name="unitElement"/>and pushes it onto
            <paramref name="context"/></summary>
            <param name="unitElement">The element to parse</param>
            <param name="context">The context to place the resulting namespace definition in</param>
        </member>
        <member name="M:ABB.SrcML.Data.AbstractCodeParser.AliasIsNamespaceImport(System.Xml.Linq.XElement)">
            <summary>
            Checks if this alias statement is a namespace import or something more specific (such as
            a type or method)
            </summary>
            <param name="aliasStatement">The alias statement to check. Must be of type see
            cref="AliasElementName"/></param>
            <returns>True if this is a namespace import; false otherwise</returns>
        </member>
        <member name="M:ABB.SrcML.Data.AbstractCodeParser.GetNamesFromAlias(System.Xml.Linq.XElement)">
            <summary>
            Gets all of the names for this alias
            </summary>
            <param name="aliasStatement">The alias statement. Must be of type see
            cref="AliasElementName"/&gt;</param>
            <returns>An enumerable of all the <see cref="F:ABB.SrcML.SRC.Name">name elements</see> for
            this statement</returns>
        </member>
        <member name="M:ABB.SrcML.Data.AbstractCodeParser.GetChildContainers(System.Xml.Linq.XElement)">
            <summary>
            Gets all of the child containers for the given container
            </summary>
            <param name="container">The container</param>
            <returns>An enumerable of all the children</returns>
        </member>
        <member name="M:ABB.SrcML.Data.AbstractCodeParser.GetChildContainersFromMethod(System.Xml.Linq.XElement)">
            <summary>
            Gets all of the child containers for a method. It calls
            <see cref="M:ABB.SrcML.Data.AbstractCodeParser.GetChildContainers(System.Xml.Linq.XElement)"/> on the child block.
            </summary>
            <param name="container">The method container</param>
            <returns>All of the child containers</returns>
        </member>
        <member name="M:ABB.SrcML.Data.AbstractCodeParser.GetChildContainersFromNamespace(System.Xml.Linq.XElement)">
            <summary>
            Gets all of the child containers for a namespace. It calls
            <see cref="M:ABB.SrcML.Data.AbstractCodeParser.GetChildContainers(System.Xml.Linq.XElement)"/> on the child block.
            </summary>
            <param name="container">The namespace container</param>
            <returns>All of the child containers</returns>
        </member>
        <member name="M:ABB.SrcML.Data.AbstractCodeParser.GetChildContainersFromType(System.Xml.Linq.XElement)">
            <summary>
            Gets all of the child containers for a type. It calls
            <see cref="M:ABB.SrcML.Data.AbstractCodeParser.GetChildContainers(System.Xml.Linq.XElement)"/> on the child block.
            </summary>
            <param name="container">The namespace type</param>
            <returns>All of the child containers</returns>
        </member>
        <member name="M:ABB.SrcML.Data.AbstractCodeParser.GetMethodCallsFromElement(System.Xml.Linq.XElement)">
            <summary>
            Gets the method calls from an element
            </summary>
            <param name="element">The element to search</param>
            <returns>All of the call elements from the element</returns>
        </member>
        <member name="M:ABB.SrcML.Data.AbstractCodeParser.GetDeclarationsFromBlockElement(System.Xml.Linq.XElement)">
            <summary>
            Gets all of the variable declarations for this block.
            </summary>
            <param name="container">The type container</param>
            <returns>An enumerable of all the declaration XElements.</returns>
        </member>
        <member name="M:ABB.SrcML.Data.AbstractCodeParser.GetDeclarationsFromCatchElement(System.Xml.Linq.XElement)">
            <summary>
            Gets all of the variable declarations for this catch block. It finds the variable
            declarations in <see cref="F:ABB.SrcML.SRC.ParameterList"/>.
            </summary>
            <param name="container">The catch container</param>
            <returns>An enumerable of all the declaration XElements.</returns>
        </member>
        <member name="M:ABB.SrcML.Data.AbstractCodeParser.GetDeclarationsFromElement(System.Xml.Linq.XElement)">
            <summary>
            Gets the declaration elements from an element
            </summary>
            <param name="element">The element to search</param>
            <returns>All of the declaration elements from an element</returns>
        </member>
        <member name="M:ABB.SrcML.Data.AbstractCodeParser.GetDeclarationsFromForElement(System.Xml.Linq.XElement)">
            <summary>
            Gets all of the variable declarations for this for loop. It finds the variable
            declaration in the <see cref="F:ABB.SrcML.SRC.Init"/> statement.
            </summary>
            <param name="container">The type container</param>
            <returns>An enumerable of all the declaration XElements.</returns>
        </member>
        <member name="M:ABB.SrcML.Data.AbstractCodeParser.GetDeclarationsFromMethodElement(System.Xml.Linq.XElement)">
            <summary>
            Gets all of the variable declarations for this method. It finds the variable
            declarations in the child block.
            </summary>
            <param name="container">The method container</param>
            <returns>An enumerable of all the declaration XElements.</returns>
        </member>
        <member name="M:ABB.SrcML.Data.AbstractCodeParser.GetDeclarationsFromTypeElement(System.Xml.Linq.XElement)">
            <summary>
            Gets all of the variable declarations for this type. It finds the variable declarations
            in the child block.
            </summary>
            <param name="container">The type container</param>
            <returns>An enumerable of all the declaration XElements.</returns>
        </member>
        <member name="M:ABB.SrcML.Data.AbstractCodeParser.GetAccessModifierForMethod(System.Xml.Linq.XElement)">
            <summary>
            Gets the access modifier for this method. For Java and C#, a "specifier" tag is placed
            in either the methodElement, or the typeElement in the method.
            </summary>
            <param name="methodElement">The methodElement</param>
            <returns>The first specifier encountered. If none, it returns see
            cref="AccessModifier.None"/></returns>
        </member>
        <member name="M:ABB.SrcML.Data.AbstractCodeParser.GetAccessModifierForType(System.Xml.Linq.XElement)">
            <summary>
            Gets the access modifier for the given type
            </summary>
            <param name="typeElement">The type XElement</param>
            <returns>The access modifier for the type.</returns>
        </member>
        <member name="M:ABB.SrcML.Data.AbstractCodeParser.GetTypeForBooleanLiteral(System.String)">
            <summary>
            Gets the type for a boolean literal
            </summary>
            <param name="literalValue">The literal value to parse</param>
            <returns>The type name</returns>
        </member>
        <member name="M:ABB.SrcML.Data.AbstractCodeParser.GetTypeForCharacterLiteral(System.String)">
            <summary>
            Gets the type for a character literal
            </summary>
            <param name="literalValue">the literal value to parse</param>
            <returns>The type name</returns>
        </member>
        <member name="M:ABB.SrcML.Data.AbstractCodeParser.GetTypeForLiteralValue(ABB.SrcML.Data.LiteralKind,System.String)">
            <summary>
            Gets the type of the literal element
            </summary>
            <param name="kind">The literal kind</param>
            <param name="literalValue">The value</param>
            <returns>The name of this type</returns>
        </member>
        <member name="M:ABB.SrcML.Data.AbstractCodeParser.GetTypeForNumberLiteral(System.String)">
            <summary>
            Gets the type for a number literal
            </summary>
            <param name="literalValue">The literal value to parse</param>
            <returns>The type name</returns>
        </member>
        <member name="M:ABB.SrcML.Data.AbstractCodeParser.GetTypeForStringLiteral(System.String)">
            <summary>
            Gets the type for a string literal
            </summary>
            <param name="literalValue">The literal value to parse</param>
            <returns>The type name</returns>
        </member>
        <member name="M:ABB.SrcML.Data.AbstractCodeParser.ParseLiteralElement(System.Xml.Linq.XElement,ABB.SrcML.Data.ParserContext)">
            <summary>
            Parses a literal use element
            </summary>
            <param name="literalElement">The literal element to parse</param>
            <param name="context">The parser context</param>
            <returns>A literal use object</returns>
        </member>
        <member name="M:ABB.SrcML.Data.AbstractCodeParser.ContainerIsReference(System.Xml.Linq.XElement)">
            <summary>
            Checks to see if this callElement is a reference container
            </summary>
            <param name="element">The callElement to check</param>
            <returns>True if this is a reference container; false otherwise</returns>
        </member>
        <member name="M:ABB.SrcML.Data.AbstractCodeParser.GetFileNameForUnit(System.Xml.Linq.XElement)">
            <summary>
            Gets the filename for the given file unit.
            </summary>
            <param name="fileUnit">The file unit. <c>fileUnit.Name</c> must be /c></param>
            <returns>The file path represented by this
            <paramref name="fileUnit"/></returns>
        </member>
        <member name="M:ABB.SrcML.Data.AbstractCodeParser.GetNameForMethod(System.Xml.Linq.XElement)">
            <summary>
            Gets the name for the method callElement
            </summary>
            <param name="methodElement">the method callElement to get the name for</param>
            <returns>The name of the method</returns>
        </member>
        <member name="M:ABB.SrcML.Data.AbstractCodeParser.GetNameForType(System.Xml.Linq.XElement)">
            <summary>
            Gets the name for the type element
            </summary>
            <param name="typeElement">The type element to get the name for</param>
            <returns>The name of the type</returns>
        </member>
        <member name="M:ABB.SrcML.Data.AbstractCodeParser.GetTextNodes(System.Xml.Linq.XElement)">
            <summary>
            Gets all of the text nodes that are children of the given element.
            </summary>
            <param name="element">The element</param>
            <returns>An enumerable of the XText elements for
            <paramref name="element"/></returns>
        </member>
        <member name="P:ABB.SrcML.Data.AbstractCodeParser.AliasElementName">
            <summary>
            Returns the XName that represents an import statement
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.AbstractCodeParser.ContainerElementNames">
            <summary>
            Returns the XNames that represent containers for this language
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.AbstractCodeParser.ContainerReferenceElementNames">
            <summary>
            Returns the XNames that represent reference elements (such as function_decl and
            class_decl)
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.AbstractCodeParser.MethodElementNames">
            <summary>
            Returns the XNames that represent types for this language
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.AbstractCodeParser.NamespaceElementNames">
            <summary>
            Returns the XNames that represent namespaces for this language
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.AbstractCodeParser.ParserLanguage">
            <summary>
            Returns the Language that this parser supports
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.AbstractCodeParser.TypeElementNames">
            <summary>
            Returns the XNames that represent types for this language
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.AbstractCodeParser.VariableDeclarationElementNames">
            <summary>
            Returns the XNames that represent variable declarations for this language
            </summary>
        </member>
        <member name="T:ABB.SrcML.Data.AbstractScopeUse`1">
            <summary>
            Abstract Scope Use is a variable use for Named Scopes. It provides an implementation of
            <see cref="M:ABB.SrcML.Data.AbstractUse`1.FindMatches"/> for resolving Named Scope uses
            </summary>
            <typeparam name="DEFINITION">The type. Must be NamedScope or a subclass</typeparam>
        </member>
        <member name="T:ABB.SrcML.Data.AbstractUse`1">
            <summary>
            The base classes for use objects. Use objects represent a use of a <see cref="T:ABB.SrcML.Data.NamedScope"/>.
            </summary>
        </member>
        <member name="M:ABB.SrcML.Data.AbstractUse`1.#ctor">
            <summary>
            Sets up the an abstract use object
            </summary>
        </member>
        <member name="M:ABB.SrcML.Data.AbstractUse`1.AddAlias(ABB.SrcML.Data.Alias)">
            <summary>
            Adds an alias. If <see cref="M:ABB.SrcML.Data.Alias.IsAliasFor``1(ABB.SrcML.Data.AbstractUse{``0})"/> returns false, then the alias is not added.
            </summary>
            <param name="alias">The alias to add</param>
        </member>
        <member name="M:ABB.SrcML.Data.AbstractUse`1.AddAliases(System.Collections.Generic.IEnumerable{ABB.SrcML.Data.Alias})">
            <summary>
            Adds an enumerable of aliases to this scope.
            </summary>
            <param name="aliasesToAdd">The aliases to add</param>
        </member>
        <member name="M:ABB.SrcML.Data.AbstractUse`1.FindMatches">
            <summary>
            Finds matching <typeparamref name="DEFINITION"/> from the <see cref="P:ABB.SrcML.Data.AbstractUse`1.ParentScopes"/> of this usage.
            </summary>
            <returns>An enumerable of <typeparamref name="DEFINITION"/> objects that <see cref="M:ABB.SrcML.Data.AbstractUse`1.Matches(`0)">matches</see> this usage.</returns>
        </member>
        <member name="M:ABB.SrcML.Data.AbstractUse`1.Matches(`0)">
            <summary>
            Tests if this usage matches the provided <paramref name="definition"/>
            </summary>
            <param name="definition">The definition to compare to</param>
            <returns>true if they are a match; false otherwise</returns>
        </member>
        <member name="M:ABB.SrcML.Data.AbstractUse`1.ToString">
            <summary>
            Returns a string representation of this object.
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.AbstractUse`1.Aliases">
            <summary>
            The aliases for this type use
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.AbstractUse`1.Location">
            <summary>
            The location of this use in the original source file and in srcML
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.AbstractUse`1.Name">
            <summary>
            The name being used
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.AbstractUse`1.ParentScope">
            <summary>
            The scope that contains this use
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.AbstractUse`1.ParentScopes">
            <summary>
            All of the parent scopes of this usage (from closest to farthest)
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.AbstractUse`1.ProgrammingLanguage">
            <summary>
            The programming language for this scope
            </summary>
        </member>
        <member name="M:ABB.SrcML.Data.AbstractScopeUse`1.FindMatches">
            <summary>
            Finds matching <typeparamref name="DEFINITION"/> from the
            <see cref="P:ABB.SrcML.Data.AbstractUse`1.ParentScopes"/> of this usage.
            </summary>
            <returns>An enumerable of <typeparamref name="DEFINITION"/> objects that
            <see cref="M:ABB.SrcML.Data.AbstractUse`1.Matches(`0)">matches</see> this usage.</returns>
        </member>
        <member name="T:ABB.SrcML.Data.AccessModifier">
            <summary>
            Enumerates the types of protection encountered in the supported programming languages
            </summary>
        </member>
        <member name="F:ABB.SrcML.Data.AccessModifier.None">
            <summary>None indicates that no access modifier was provided</summary>
        </member>
        <member name="F:ABB.SrcML.Data.AccessModifier.Public">
            <summary>Public</summary>
        </member>
        <member name="F:ABB.SrcML.Data.AccessModifier.ProtectedInternal">
            <summary>Protected Internal, used in C#</summary>
        </member>
        <member name="F:ABB.SrcML.Data.AccessModifier.Protected">
            <summary>Protected</summary>
        </member>
        <member name="F:ABB.SrcML.Data.AccessModifier.Internal">
            <summary>Internal</summary>
        </member>
        <member name="F:ABB.SrcML.Data.AccessModifier.Private">
            <summary>Private</summary>
        </member>
        <member name="T:ABB.SrcML.Data.AccessModifierExtensions">
            <summary>
            Contains extension methods for the AccessModifier enum.
            </summary>
        </member>
        <member name="M:ABB.SrcML.Data.AccessModifierExtensions.ToKeywordString(ABB.SrcML.Data.AccessModifier)">
            <summary>
            Converts the enum value to its programming language keyword equivalent.
            </summary>
        </member>
        <member name="T:ABB.SrcML.Data.Alias">
            <summary>
            Represents an import or using directive (usually found at the top of a source file)
            </summary>
        </member>
        <member name="M:ABB.SrcML.Data.Alias.#ctor">
            <summary>
            Constructs a new alias object
            </summary>
        </member>
        <member name="M:ABB.SrcML.Data.Alias.FindMatchingNamespace(ABB.SrcML.Data.NamespaceDefinition)">
            <summary>
            Finds a namespace that matches the <see cref="P:ABB.SrcML.Data.Alias.ImportedNamespace"/> portion of this alias.
            </summary>
            <param name="rootScope">the global scope to search from</param>
            <returns>namespace definitions rooted at <paramref name="rootScope"/> that match <see cref="P:ABB.SrcML.Data.Alias.ImportedNamespace"/></returns>
        </member>
        <member name="M:ABB.SrcML.Data.Alias.GetNamespaceName">
            <summary>
            Constructs the namespace name for this alias
            </summary>
            <returns>the namespace name</returns>
        </member>
        <member name="M:ABB.SrcML.Data.Alias.GetFullName">
            <summary>
            Gets the full name for this alias
            </summary>
            <returns>the full name for this alias</returns>
        </member>
        <member name="M:ABB.SrcML.Data.Alias.IsAliasFor``1(ABB.SrcML.Data.AbstractUse{``0})">
            <summary>
            Checks if this is a valid alias for the given type use. Namespace prefixes are always valid.
            Other prefixes must have <see cref="P:ABB.SrcML.Data.Alias.ImportedNamedScope"/> match <see cref="P:ABB.SrcML.Data.AbstractUse`1.Name"/>
            </summary>
            <param name="use">the type use to check</param>
            <returns>true if this alias may represent this type use.</returns>
        </member>
        <member name="M:ABB.SrcML.Data.Alias.IsAliasFor(ABB.SrcML.Data.NamedScope)">
            <summary>
            Checks to see if this is an alias for <paramref name="namedScope"/>
            </summary>
            <param name="namedScope">The named scope to check</param>
            <returns>True if this alias can apply to the provided named scope; false otherwise</returns>
        </member>
        <member name="P:ABB.SrcML.Data.Alias.ImportedNamespace">
            <summary>
            The namespace root identified by this alias
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.Alias.ImportedNamedScope">
            <summary>
            the specific object identified by this alias
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.Alias.IsNamespaceImport">
            <summary>
            Returns true if this is a namespace alias (true if the name is not set).
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.Alias.Location">
            <summary>
            The location of this alias in both the source file and the XML.
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.Alias.ProgrammingLanguage">
            <summary>
            The programming language this alias was produced from
            </summary>
        </member>
        <member name="T:ABB.SrcML.Data.BuiltInTypeFactory">
            <summary>
            The Built-In type factory creates on-demand instances of built-in types for each language. It creates and stores one <see cref="T:ABB.SrcML.Data.TypeDefinition"/> object for
            each <see cref="T:ABB.SrcML.Language"/>/built-in type pair. This factory is primarily used by when comparing <see cref="T:ABB.SrcML.Data.TypeUse"/> objects for method parameters.
            A parameter and an argument should have the same <see cref="T:ABB.SrcML.Data.TypeDefinition"/> object.
            </summary>
        </member>
        <member name="M:ABB.SrcML.Data.BuiltInTypeFactory.GetBuiltIn(ABB.SrcML.Data.TypeUse)">
            <summary>
            Returns the built-in type for the given type use
            </summary>
            <param name="use">the type use to locate</param>
            <returns>A type definition that matches the type use; null if this is not a built-in</returns>
        </member>
        <member name="M:ABB.SrcML.Data.BuiltInTypeFactory.IsBuiltIn(ABB.SrcML.Data.TypeUse)">
            <summary>
            Checks if the <paramref name="use">given type use</paramref> is a built-in type.
            </summary>
            <param name="use">The type use to test</param>
            <returns>true if this is a built-in type; false otherwise</returns>
        </member>
        <member name="T:ABB.SrcML.Data.TypeUse">
            <summary>
            Represents a use of a type. It is used in declarations and inheritance specifications.
            </summary>
        </member>
        <member name="T:ABB.SrcML.Data.IResolvesToType">
            <summary>
            This interface provides methods that <see cref="T:ABB.SrcML.Data.AbstractUse`1"/> objects should implement if they should resolve to a return type
            <see cref="M:ABB.SrcML.Data.IResolvesToType.FindFirstMatchingType"/> should be a call to <c><see cref="M:ABB.SrcML.Data.IResolvesToType.FindMatchingTypes"/>.FirstOrDefault()</c>
            </summary>
        </member>
        <member name="M:ABB.SrcML.Data.IResolvesToType.FindMatchingTypes">
            <summary>
            Finds all of the possible matching types for this usage
            </summary>
            <returns>An enumerable of type definition objects</returns>
        </member>
        <member name="M:ABB.SrcML.Data.IResolvesToType.FindFirstMatchingType">
            <summary>
            Returns the first matching type definition returned by <see cref="M:ABB.SrcML.Data.IResolvesToType.FindMatchingTypes"/>
            </summary>
            <returns>The first matching type definition. Null if there aren't any.</returns>
        </member>
        <member name="P:ABB.SrcML.Data.IResolvesToType.CallingObject">
            <summary>
            The calling object
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.IResolvesToType.ParentScope">
            <summary>
            The parent scope for this calling object
            </summary>
        </member>
        <member name="M:ABB.SrcML.Data.TypeUse.#ctor">
            <summary>
            Create a new type use object.
            </summary>
        </member>
        <member name="M:ABB.SrcML.Data.TypeUse.AddTypeParameter(ABB.SrcML.Data.TypeUse)">
            <summary>
            Adds a generic type parameter to this type use
            </summary>
            <param name="typeParameter">The type parameter to add</param>
        </member>
        <member name="M:ABB.SrcML.Data.TypeUse.AddTypeParameters(System.Collections.Generic.IEnumerable{ABB.SrcML.Data.TypeUse})">
            <summary>
            Adds all of the type parameters to this type use element
            </summary>
            <param name="typeParameters">An enumerable of type use elements to add</param>
        </member>
        <member name="M:ABB.SrcML.Data.TypeUse.FindFirstMatchingType">
            <summary>
            Gets the first type that matches this use
            </summary>
            <returns>The matching type; null if there aren't any</returns>
        </member>
        <member name="M:ABB.SrcML.Data.TypeUse.FindMatches">
            <summary>
            Finds all of the matches for this type
            </summary>
            <returns>All of the type definitions that match this type use</returns>
        </member>
        <member name="M:ABB.SrcML.Data.TypeUse.FindMatchingTypes">
            <summary>
            This is just a call to <see cref="M:ABB.SrcML.Data.TypeUse.FindMatches"/>
            </summary>
            <returns>The matching type definitions for this use</returns>
        </member>
        <member name="M:ABB.SrcML.Data.TypeUse.Matches(ABB.SrcML.Data.TypeDefinition)">
            <summary>
            Tests if this type use is a match for the given
            <paramref name="definition"/></summary>
            <param name="definition">the definition to compare to</param>
            <returns>true if the definitions match; false otherwise</returns>
        </member>
        <member name="M:ABB.SrcML.Data.TypeUse.ToString">
            <summary>
            Returns a string representation of this object.
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.TypeUse.CallingObject">
            <summary>
            The calling object for this type (should be unused)
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.TypeUse.IsGeneric">
            <summary>
            Returns true if <see cref="P:ABB.SrcML.Data.TypeUse.TypeParameters"/> has any elements
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.TypeUse.Prefix">
            <summary>
            The prefix for this type use object
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.TypeUse.TypeParameters">
            <summary>
            Parameters for the type use (indicates that this is a generic type use)
            </summary>
        </member>
        <member name="T:ABB.SrcML.Data.LiteralKind">
            <summary>
            An enumeration of the different kinds of literals
            </summary>
        </member>
        <member name="F:ABB.SrcML.Data.LiteralKind.String">
            <summary>String literal</summary>
        </member>
        <member name="F:ABB.SrcML.Data.LiteralKind.Boolean">
            <summary>Boolean literal</summary>
        </member>
        <member name="F:ABB.SrcML.Data.LiteralKind.Character">
            <summary>Character literal</summary>
        </member>
        <member name="F:ABB.SrcML.Data.LiteralKind.Number">
            <summary>Number literal</summary>
        </member>
        <member name="T:ABB.SrcML.Data.LiteralUse">
            <summary>
            Literal use is a specific kind of type use that refers to a language's built-in types.
            </summary>
        </member>
        <member name="M:ABB.SrcML.Data.LiteralUse.GetLiteralKind(System.Xml.Linq.XElement)">
            <summary>
            Gets the literal kind from the <paramref name="literalElement"/>
            </summary>
            <param name="literalElement">The literal element</param>
            <returns>The kind of element this is</returns>
        </member>
        <member name="P:ABB.SrcML.Data.LiteralUse.Kind">
            <summary>
            The kind of literal
            </summary>
        </member>
        <member name="T:ABB.SrcML.Data.CSharpCodeParser">
            <summary>
            Provides parsing facilities for the C# language
            </summary>
        </member>
        <member name="M:ABB.SrcML.Data.CSharpCodeParser.#ctor">
            <summary>
            Constructs a C# code parser
            </summary>
        </member>
        <member name="M:ABB.SrcML.Data.CSharpCodeParser.AliasIsNamespaceImport(System.Xml.Linq.XElement)">
            <summary>
            Checks if the using statement is a namespace import
            </summary>
            <param name="aliasStatement"></param>
            <returns></returns>
        </member>
        <member name="M:ABB.SrcML.Data.CSharpCodeParser.ContainerIsReference(System.Xml.Linq.XElement)">
            <summary>
            Tests whether this container is a reference or whether it includes a definition.
            </summary>
            <param name="element">The element to test</param>
            <returns>True if this is a reference element; false otherwise</returns>
        </member>
        <member name="M:ABB.SrcML.Data.CSharpCodeParser.GetParentTypeUseElements(System.Xml.Linq.XElement)">
            <summary>
            Gets the parent type elements for a type element
            </summary>
            <param name="typeElement">The type element to parse</param>
            <returns>The type use elements</returns>
        </member>
        <member name="M:ABB.SrcML.Data.CSharpCodeParser.GetTypeForBooleanLiteral(System.String)">
            <summary>
            Parses a C# boolean literal
            </summary>
            <param name="literalValue">The literal value</param>
            <returns>returns "bool"</returns>
        </member>
        <member name="M:ABB.SrcML.Data.CSharpCodeParser.GetTypeForCharacterLiteral(System.String)">
            <summary>
            Parses a C# character literal
            </summary>
            <param name="literalValue">The literal value</param>
            <returns>returns "char"</returns>
        </member>
        <member name="M:ABB.SrcML.Data.CSharpCodeParser.GetTypeForNumberLiteral(System.String)">
            <summary>
            Parses a C# number literal based on C# 4.0 in a Nutshell by Joseph Albahari and Ben
            Albahari, page 22.
            </summary>
            <param name="literalValue">The literal value</param>
            <returns>returns the appropriate numeric type</returns>
        </member>
        <member name="M:ABB.SrcML.Data.CSharpCodeParser.GetTypeForStringLiteral(System.String)">
            <summary>
            Parses a C# string literal
            </summary>
            <param name="literalValue">The literal value</param>
            <returns>Returns "string"</returns>
        </member>
        <member name="M:ABB.SrcML.Data.CSharpCodeParser.ParseNamespaceElement(System.Xml.Linq.XElement,ABB.SrcML.Data.ParserContext)">
            <summary>
            Parses a C# namespace block
            </summary>
            <param name="namespaceElement">the namespace element to parse</param>
            <param name="context">the parser context</param>
        </member>
        <member name="M:ABB.SrcML.Data.CSharpCodeParser.ParseTypeElement(System.Xml.Linq.XElement,ABB.SrcML.Data.ParserContext)">
            <summary>
            Parses the given typeElement and returns a TypeDefinition object.
            </summary>
            <param name="typeElement">the type XML type element.</param>
            <param name="context">the parser context</param>
            <returns>A new TypeDefinition object</returns>
        </member>
        <member name="M:ABB.SrcML.Data.CSharpCodeParser.ParseTypeUseElement(System.Xml.Linq.XElement,ABB.SrcML.Data.ParserContext)">
            <summary>
            Parses the given typeUseElement and returns a TypeUse object. This handles the "var" keyword for C# if used
            </summary>
            <param name="typeUseElement">The XML type use element</param>
            <param name="context">The parser context</param>
            <returns>A new TypeUse object</returns>
        </member>
        <member name="P:ABB.SrcML.Data.CSharpCodeParser.ParserLanguage">
            <summary>
            Returns <c>Language.CSharp</c>
            </summary>
        </member>
        <member name="T:ABB.SrcML.Data.MethodCall">
            <summary>
            Represents a method call
            </summary>
        </member>
        <member name="M:ABB.SrcML.Data.MethodCall.#ctor">
            <summary>
            Creates a new MethodCall object
            </summary>
        </member>
        <member name="M:ABB.SrcML.Data.MethodCall.FindFirstMatchingType">
            <summary>
            Gets the first type definition that matches the return type for this method
            </summary>
            <returns>The first matching type definition</returns>
        </member>
        <member name="M:ABB.SrcML.Data.MethodCall.FindMatches">
            <summary>
            Finds matching <see cref="T:ABB.SrcML.Data.MethodDefinition">method definitions</see> from the
            <see cref="M:ABB.SrcML.Data.Scope.GetParentScopes"/> of this usage. Because method calls can also be to
            constructors and destructors, this will also search for matching types and then
            constructors within those types
            </summary>
            <returns>An enumerable of method definitions that match this method call</returns>
        </member>
        <member name="M:ABB.SrcML.Data.MethodCall.FindMatchingTypes">
            <summary>
            Finds all of the matching type definitions for the return type of this method definition
            </summary>
            <returns>An enumerable of the matching type definitions for this method</returns>
        </member>
        <member name="M:ABB.SrcML.Data.MethodCall.Matches(ABB.SrcML.Data.MethodDefinition)">
            <summary>
            Tests if the provided method definition matches this method call
            </summary>
            <param name="definition">The method definition to test</param>
            <returns>True if this method call matches the provided method definition</returns>
        </member>
        <member name="M:ABB.SrcML.Data.MethodCall.ArgumentMatchesDefinition(ABB.SrcML.Data.IResolvesToType,ABB.SrcML.Data.ParameterDeclaration)">
            <summary>
            Computes the intersection of the matching types for
            <paramref name="argument"/>and
            <paramref name="parameter"/>. It returns true if the intersection has any elements in
            it.
            </summary>
            <param name="argument">an argument from see cref="Arguments"/></param>
            <param name="parameter">a parameter from see
            cref="MethodDefinition.Parameters"/></param>
            <returns>true if the argument and the parameter have a matching type in common; false
            otherwise</returns>
        </member>
        <member name="P:ABB.SrcML.Data.MethodCall.Arguments">
            <summary>
            The arguments to this call
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.MethodCall.CallingObject">
            <summary>
            The calling object for a use is used when you have <c>a.Foo()</c> -- this method call
            would refer to <c>Foo()</c> and the calling object would be <c>a</c>.
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.MethodCall.IsConstructor">
            <summary>
            True if this is a call to a constructor
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.MethodCall.IsDestructor">
            <summary>
            True if this is a call to a destructor
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.MethodCall.ParentScope">
            <summary>
            The parent scope for this method call. When you update the parent scope, the object also
            updates the parent scope of <see cref="P:ABB.SrcML.Data.MethodCall.CallingObject"/> and all of the
            <see cref="P:ABB.SrcML.Data.MethodCall.Arguments"/>
            </summary>
        </member>
        <member name="T:ABB.SrcML.Data.NamedScope">
            <summary>
            <para>This is a variable scope that can be identified by name. Its subclasses identify specific constructs
            in the code that have a name. It is also used by <see cref="T:ABB.SrcML.Data.CPlusPlusCodeParser"/> to represent unresolved
            scopes.</para>
            <para>Sub-classes of this include <see cref="T:ABB.SrcML.Data.TypeDefinition"/>, <see cref="T:ABB.SrcML.Data.NamespaceDefinition"/>,
            and <see cref="T:ABB.SrcML.Data.MethodDefinition"/></para>
            </summary>
        </member>
        <member name="T:ABB.SrcML.Data.Scope">
            <summary>
            The Scope class is the base class for variable scope objects. It encapsulates the basics of the type hierarchy (parent-child relationships)
            and contains methods for adding child scopes and variable declarations.
            </summary>
        </member>
        <member name="F:ABB.SrcML.Data.Scope.ChildScopeMap">
            <summary>
            Holds all of the children for this scope.
            </summary>
        </member>
        <member name="F:ABB.SrcML.Data.Scope.DeclaredVariablesDictionary">
            <summary>
            Holds all of the variable declarations declared here. The key is the variable name.
            </summary>
        </member>
        <member name="F:ABB.SrcML.Data.Scope.MethodCallCollection">
            <summary>
            Holds all of the method calls for this scope
            </summary>
        </member>
        <member name="F:ABB.SrcML.Data.Scope.LocationDictionary">
            <summary>
            Holds all of the source locations for this scope. The key is a filename.
            the value is a collection of sourcelocations in that file where this scope has been defined.
            </summary>
        </member>
        <member name="M:ABB.SrcML.Data.Scope.#ctor">
            <summary>
            Initializes an empty variable scope.
            </summary>
        </member>
        <member name="M:ABB.SrcML.Data.Scope.#ctor(ABB.SrcML.Data.Scope)">
            <summary>
            Copy constructor
            </summary>
            <param name="otherScope">The scope to copy from</param>
        </member>
        <member name="M:ABB.SrcML.Data.Scope.GetChildScopes``1">
            <summary>
            Gets all of the scopes from <see cref="P:ABB.SrcML.Data.Scope.ChildScopes"/> that match <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type to filter child scopes with</typeparam>
            <returns>An enumerable of child scopes of type <typeparamref name="T"/></returns>
        </member>
        <member name="M:ABB.SrcML.Data.Scope.GetDescendantScopes">
            <summary>
            Gets all of the descendants from this scope. This is every scope that is rooted at this scope.
            </summary>
            <returns>The descendants of this scope</returns>
        </member>
        <member name="M:ABB.SrcML.Data.Scope.GetDescendantScopes``1">
            <summary>
            Gets all of the descendants from this scope where the type is <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type to filter the descendant scopes by</typeparam>
            <returns>An enumerable of descendants of type <typeparamref name="T"/></returns>
        </member>
        <member name="M:ABB.SrcML.Data.Scope.GetDescendantScopesAndSelf">
            <summary>
            Gets all of the descendants from this scope as well as the scope itself.
            </summary>
            <returns>This scope, followed by all of it descendants</returns>
        </member>
        <member name="M:ABB.SrcML.Data.Scope.GetDescendantScopesAndSelf``1">
            <summary>
            Gets all of the scopes of type <typeparamref name="T"/> from the set of this scope and its descendants.
            </summary>
            <typeparam name="T">the type to filter by</typeparam>
            <returns>An enumerable of scopes of type <typeparamref name="T"/></returns>
        </member>
        <member name="M:ABB.SrcML.Data.Scope.GetFirstDescendant``1">
            <summary>
            Gets the first descendant of this scope of type <typeparamref name="T"/>
            </summary>
            <typeparam name="T">the tyep to filter by</typeparam>
            <returns>the first matching descendant of this scope</returns>
        </member>
        <member name="M:ABB.SrcML.Data.Scope.GetFirstParent``1">
            <summary>
            Gets the first scope of type <typeparamref name="T"/> from <see cref="M:ABB.SrcML.Data.Scope.GetParentScopesAndSelf``1"/>
            </summary>
            <typeparam name="T">The type to look for</typeparam>
            <returns>The first scope of type <typeparamref name="T"/></returns>
        </member>
        <member name="M:ABB.SrcML.Data.Scope.GetParentScopes">
            <summary>
            Gets all of the parent scopes of this scope
            </summary>
            <returns>An enumerable (in reverse order) of all of the parent scopes</returns>
        </member>
        <member name="M:ABB.SrcML.Data.Scope.GetParentScopes``1">
            <summary>
            Gets all of the parent scopes of type <typeparamref name="T"/>
            </summary>
            <typeparam name="T">The type to look for</typeparam>
            <returns>An enumerable (in reverse order) of all of the parent scopes of type <typeparamref name="T"/></returns>
        </member>
        <member name="M:ABB.SrcML.Data.Scope.GetParentScopesAndSelf">
            <summary>
            returns an enumerable consisting of this element and all of its parents
            </summary>
            <returns>An enumerable (in reverse order) of this element and all of its parents</returns>
        </member>
        <member name="M:ABB.SrcML.Data.Scope.GetParentScopesAndSelf``1">
            <summary>
            Returns an enumerable consisting of this element and all of its parent scopes of type <typeparamref name="T"/>
            </summary>
            <typeparam name="T">The type to look for</typeparam>
            <returns>An enumerable (in reverse order) of this element and all of its parents of type <typeparamref name="T"/></returns>
        </member>
        <member name="M:ABB.SrcML.Data.Scope.AddChildScope(ABB.SrcML.Data.Scope)">
            <summary>
            Adds a child scope to this scope
            </summary>
            <param name="childScope">The child scope to add.</param>
        </member>
        <member name="M:ABB.SrcML.Data.Scope.AddDeclaredVariable(ABB.SrcML.Data.VariableDeclaration)">
            <summary>
            Add a variable declaration to this scope
            </summary>
            <param name="declaration">The variable declaration to add.</param>
        </member>
        <member name="M:ABB.SrcML.Data.Scope.AddMethodCall(ABB.SrcML.Data.MethodCall)">
            <summary>
            Adds a method call
            </summary>
            <param name="methodCall">the method call to add</param>
        </member>
        <member name="M:ABB.SrcML.Data.Scope.AddSourceLocation(ABB.SrcML.Data.SrcMLLocation)">
            <summary>
            Adds a new srcML location to this scope.
            </summary>
            <param name="location">the location to add</param>
        </member>
        <member name="M:ABB.SrcML.Data.Scope.GetChildScopesWithId(System.String)">
            <summary>
            Gets all of the child scopes that match <paramref name="id"/>. This works by simply returning the matching list in <see cref="F:ABB.SrcML.Data.Scope.ChildScopeMap"/>.
            </summary>
            <param name="id">The id to look for</param>
            <returns>All of the child scopes with the given id -- if there are none, it returns <see cref="M:System.Linq.Enumerable.Empty``1"/></returns>
        </member>
        <member name="M:ABB.SrcML.Data.Scope.GetChildScopesWithId``1(System.String)">
            <summary>
            Gets all of the child scopes that match <paramref name="id"/> and have type <typeparamref name="T"/>.
            This works by simply returning the matching list in <see cref="F:ABB.SrcML.Data.Scope.ChildScopeMap"/>.
            </summary>
            <typeparam name="T">The type to filter by</typeparam>
            <param name="id">The id to look for</param>
            <returns>All of the child scopes with the matching <paramref name="id"/> and type <typeparamref name="T"/> --
            if there are none, it returns <see cref="M:System.Linq.Enumerable.Empty``1"/></returns>
        </member>
        <member name="M:ABB.SrcML.Data.Scope.ExistsInFile(System.String)">
            <summary>
            Checks if this scope was defined in <paramref name="fileName"/>.
            </summary>
            <param name="fileName">The filename to lookup.</param>
            <returns>True if this scope contains locations in <paramref name="fileName"/>; false otherwise</returns>
        </member>
        <member name="M:ABB.SrcML.Data.Scope.GetLocationsInFile(System.String)">
            <summary>
            Gets all of the locations for a particular <paramref name="fileName"/>.
            </summary>
            <param name="fileName">The file name to get locations for</param>
            <returns>A collection of <see cref="T:ABB.SrcML.Data.SourceLocation"/> objects. If this scope was not defined in <paramref name="fileName"/>, null is returned.</returns>
        </member>
        <member name="M:ABB.SrcML.Data.Scope.Merge(ABB.SrcML.Data.Scope)">
            <summary>
            The merge function merges two scopes if they are the same. It assumes that the parents of the two scopes are identical.
            Because of this, it is best to call it on two "global scope" objects. If the two scopes are the same (as determined by
            the <see cref="M:ABB.SrcML.Data.Scope.CanBeMergedInto(ABB.SrcML.Data.Scope)"/> method), then the variable declarations in <paramref name="otherScope"/> then a new
            Scope with all the children of the both scopes is returned.
            </summary>
            <param name="otherScope">The scope to merge with</param>
            <returns>A new variable scope if the scopes <see cref="M:ABB.SrcML.Data.Scope.CanBeMergedInto(ABB.SrcML.Data.Scope)">could be merged</see>; null otherwise</returns>
        </member>
        <member name="M:ABB.SrcML.Data.Scope.AddFrom(ABB.SrcML.Data.Scope)">
            <summary>
            The AddFrom function adds all of the declarations and children from <paramref name="otherScope"/> to this scope
            </summary>
            <param name="otherScope">The scope to add data from</param>
            <returns>the new scope</returns>
        </member>
        <member name="M:ABB.SrcML.Data.Scope.CanBeMergedInto(ABB.SrcML.Data.Scope)">
            <summary>
            Tests value equality between this scope and <paramref name="otherScope"/>.
            Two scopes are equal if they have the same <see cref="P:ABB.SrcML.Data.SrcMLLocation.XPath"/>.
            </summary>
            <param name="otherScope">The scope to compare to</param>
            <returns>True if the scopes are the same. False otherwise.</returns>
        </member>
        <member name="M:ABB.SrcML.Data.Scope.IsScopeFor(System.Xml.Linq.XElement)">
            <summary>
            Returns true if this variable scope contains the given XElement. A variable scope contains an element if <see cref="P:ABB.SrcML.Data.SrcMLLocation.XPath"/> is a 
            prefix for the XPath for <paramref name="element"/>.
            </summary>
            <param name="element">The element to look for</param>
            <returns>true if this is a container for <paramref name="element"/>. False otherwise.</returns>
        </member>
        <member name="M:ABB.SrcML.Data.Scope.IsScopeFor(System.String)">
            <summary>
            Returns true if this variable scope contains the given XPath. A variable scope contains an xpath if <see cref="P:ABB.SrcML.Data.SrcMLLocation.XPath"/> is a prefix for <paramref name="xpath"/>
            </summary>
            <param name="xpath">The xpath to look for.</param>
            <returns>True if this is a container for the given xpath. False, otherwise.</returns>
        </member>
        <member name="M:ABB.SrcML.Data.Scope.IsScopeFor(ABB.SrcML.Data.SourceLocation)">
            <summary>
            Returns true if this scope surrounds the given source location. 
            </summary>
            <param name="loc">The source location to look for.</param>
            <returns>True if this is a container for the given location, False otherwise.</returns>
        </member>
        <member name="M:ABB.SrcML.Data.Scope.GetScopeForLocation(System.String)">
            <summary>
            Returns the innermost scope that contains the given xpath. 
            </summary>
            <param name="xpath">the xpath to find containers for.</param>
            <returns>The lowest child of this scope that contains the given xpath, or null if it cannot be found.</returns>
        </member>
        <member name="M:ABB.SrcML.Data.Scope.GetScopeForLocation(ABB.SrcML.Data.SourceLocation)">
            <summary>
            Returns the innermost scope that surrounds the given source location. 
            </summary>
            <param name="loc">The source location to search for.</param>
            <returns>The lowest child of this scope that surrounds the given location, or null if it cannot be found.</returns>
        </member>
        <member name="M:ABB.SrcML.Data.Scope.GetDeclarationsForVariableName(System.String,System.String)">
            <summary>
            Searches this scope and all of its children for variable declarations that match the given variable name and xpath.
            It finds all the scopes where the xpath is valid and all of the declarations in those scopes that match the variable name.
            </summary>
            <param name="variableName">the variable name to search for.</param>
            <param name="xpath">the xpath for the variable name</param>
            <returns>An enumerable of matching variable declarations.</returns>
        </member>
        <member name="M:ABB.SrcML.Data.Scope.RemoveChild(ABB.SrcML.Data.Scope)">
            <summary>
            Removes the given child scope.
            </summary>
            <param name="childScope">The child scope to remove.</param>
        </member>
        <member name="M:ABB.SrcML.Data.Scope.RemoveFile(System.String)">
            <summary>
            Removes any program elements defined in the given file.
            If the scope is defined entirely within the given file, then it removes itself from its parent.
            </summary>
            <param name="fileName">The file to remove.</param>
            <returns>A collection of any unresolved scopes that result from removing the file. The caller is responsible for re-resolving these as appropriate.</returns>
        </member>
        <member name="M:ABB.SrcML.Data.Scope.CopyFromOtherScope(ABB.SrcML.Data.Scope)">
            <summary>
            Copies the values from another Scope into this one.
            This is intentially separate from AddFrom(), because it is called from the copy constructor and so must be non-virtual.
            </summary>
            <param name="otherScope"></param>
        </member>
        <member name="M:ABB.SrcML.Data.Scope.ToString">
            <summary>
            Creates a string representation for this scope
            </summary>
            <returns>A string that describes this scope</returns>
        </member>
        <member name="M:ABB.SrcML.Data.Scope.ToString(System.String)">
            <summary>
            Creates a string representation for this scope
            </summary>
            <param name="typeName">The type of scope</param>
            <returns>A string that describes this scope</returns>
        </member>
        <member name="M:ABB.SrcML.Data.Scope.ToString(System.String,System.String)">
            <summary>
            Creates a string representation for this scope
            </summary>
            <param name="typeName">The type of scope</param>
            <param name="identifier">An identifier for this scope (does not have to be unique)</param>
            <returns>A string that describes this scope</returns>
        </member>
        <member name="P:ABB.SrcML.Data.Scope.Id">
            <summary>
            <para>Gets an identifier for this scope. Identifiers do not have to be unique.
            They are used to collect scopes with the same ID into buckets in <see cref="F:ABB.SrcML.Data.Scope.ChildScopeMap"/></para>
            <para>For Scopes, the identifier is the <see cref="P:ABB.SrcML.Data.Scope.PrimaryLocation">primary XPath</see>. In practice, this means that 
            each scope will always be sorted into its own lists.</para>
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.Scope.ProgrammingLanguage">
            <summary>
            Indicates the programming language used to create this scope
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.Scope.ParentScope">
            <summary>
            The parent container for this scope.
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.Scope.ChildScopes">
            <summary>
            Iterates over all of the child scopes of this scope
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.Scope.DeclaredVariables">
            <summary>
            Iterates over all of the variable declarations for this scope
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.Scope.MethodCalls">
            <summary>
            Iterates over all of the method calls in this scope
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.Scope.PrimaryLocation">
            <summary>
            References the primary location where this location has been defined.
            For Scope objects, the primary location is simply the first <see cref="P:ABB.SrcML.Data.SrcMLLocation.IsReference">non-reference</see>location that was added.
            if there are no <see cref="P:ABB.SrcML.Data.SrcMLLocation.IsReference">non-reference locations</see>, the first location is added.
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.Scope.Locations">
            <summary>
            An enumerable of all the source location objects that this scope is defined at.
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.Scope.DefinitionLocations">
            <summary>
            An enumerable of all the locations where <see cref="P:ABB.SrcML.Data.SrcMLLocation.IsReference"/> is false
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.Scope.ReferenceLocations">
            <summary>
            An enumerable of all the locations where <see cref="P:ABB.SrcML.Data.SrcMLLocation.IsReference"/> is true
            </summary>
        </member>
        <member name="M:ABB.SrcML.Data.NamedScope.#ctor">
            <summary>
            Create a new object
            </summary>
        </member>
        <member name="M:ABB.SrcML.Data.NamedScope.#ctor(ABB.SrcML.Data.NamedScope)">
            <summary>
            Copy constructor
            </summary>
            <param name="otherScope">The scope to copy from</param>
        </member>
        <member name="M:ABB.SrcML.Data.NamedScope.GetFullName">
            <summary>
            Gets the full name by finding all of the named scope ancestors and combining them.
            </summary>
            <returns>The full name for this scope</returns>
        </member>
        <member name="M:ABB.SrcML.Data.NamedScope.AddChildScope(ABB.SrcML.Data.Scope)">
            <summary>
            Adds a child scope to this object. If the child scope is a <see cref="T:ABB.SrcML.Data.Scope"/>
            It setups all of the unresolved links between this scope and the <paramref name="childScope"/>
            </summary>
            <param name="childScope">the child scope to add</param>
        </member>
        <member name="M:ABB.SrcML.Data.NamedScope.AddNamedChildScope(ABB.SrcML.Data.NamedScope)">
            <summary>
            Sets up unresolved links between this and <paramref name="childScope"/> if needed.
            </summary>
            <param name="childScope">The child scope to add</param>
        </member>
        <member name="M:ABB.SrcML.Data.NamedScope.SelectUnresolvedScope">
            <summary>
            Selects the most likely unresolved path to this element. Currently, it always selects the first element.
            Calling this sets <see cref="P:ABB.SrcML.Data.NamedScope.UnresolvedParentScopeInUse"/>.
            </summary>
            <returns><see cref="P:ABB.SrcML.Data.NamedScope.UnresolvedParentScopeInUse"/> unless there are no <see cref="P:ABB.SrcML.Data.NamedScope.ParentScopeCandidates"/>. Then it returns null</returns>
        </member>
        <member name="M:ABB.SrcML.Data.NamedScope.Merge(ABB.SrcML.Data.Scope)">
            <summary>
            <para>Merges NamedVariableScopes together. It works like this:</para>
            <para>If both objects are the same type, it merges <paramref name="otherScope"/> with this.</para>
            <para>If this is a subclass of NamedScope and <paramref name="otherScope"/> is not, it merges otherScope with this.</para>
            <para>If this is a NamedScope and <paramref name="otherScope"/> is a subclass, it merges this with otherScope</para>
            <para>If the two objects cannot be merged, it does not merge them.</para>
            <para><seealso cref="M:ABB.SrcML.Data.NamedScope.CanBeMergedInto(ABB.SrcML.Data.NamedScope)">CanBeMergedInto is used to decide if the two objects can be merged.</seealso></para>
            </summary>
            <param name="otherScope">The scope to merge with</param>
            <returns>The merged scope. null if they cannot be merged.</returns>
        </member>
        <member name="M:ABB.SrcML.Data.NamedScope.Merge(ABB.SrcML.Data.NamedScope)">
            <summary>
            Merges two NamedVariableScopes together. It works like this:
            <list type="bullet">
            <item><description>If this is the same type or more specific than <paramref name="otherScope"/>, then create a new merged NamedScope
            from <paramref name="otherScope"/> and this.</description></item>
            <item><description>If <paramref name="otherScope"/> is more specific than this, call <c>otherScope.Merge</c></description></item>
            </list>
            </summary>
            <param name="otherScope">The scope to merge with</param>
            <returns>The new merged scope; null if they couldn't be merged</returns>
        </member>
        <member name="M:ABB.SrcML.Data.NamedScope.AddFrom(ABB.SrcML.Data.Scope)">
            <summary>
            The AddFrom function adds all of the declarations and children from <paramref name="otherScope"/> to this scope
            </summary>
            <param name="otherScope">The scope to add data from</param>
            <returns>the new scope</returns>
        </member>
        <member name="M:ABB.SrcML.Data.NamedScope.CanBeMergedInto(ABB.SrcML.Data.Scope)">
            <summary>
            Overrides <see cref="M:ABB.SrcML.Data.Scope.CanBeMergedInto(ABB.SrcML.Data.Scope)"/> to call <see cref="M:ABB.SrcML.Data.NamedScope.CanBeMergedInto(ABB.SrcML.Data.NamedScope)"/>
            </summary>
            <param name="otherScope">the scope to test</param>
            <returns>true if the two objects can be merged, false otherwise</returns>
        </member>
        <member name="M:ABB.SrcML.Data.NamedScope.CanBeMergedInto(ABB.SrcML.Data.NamedScope)">
            <summary>
            Two NamedScope objects can be merged if they share the same name.
            </summary>
            <param name="otherScope">The scope to test</param>
            <returns>true if the two objects have the same <see cref="P:ABB.SrcML.Data.NamedScope.Name"/>. False, otherwise.</returns>
        </member>
        <member name="M:ABB.SrcML.Data.NamedScope.RemoveFile(System.String)">
            <summary>
            Removes any program elements defined in the given file.
            If the scope is defined entirely within the given file, then it removes itself from its parent.
            </summary>
            <param name="fileName">The file to remove.</param>
            <returns>A collection of any unresolved scopes that result from removing the file. The caller is responsible for re-resolving these as appropriate.</returns>
        </member>
        <member name="M:ABB.SrcML.Data.NamedScope.ToString">
            <summary>
            Creates a string representation of this named scope
            </summary>
            <returns>String that describes this named scope</returns>
        </member>
        <member name="P:ABB.SrcML.Data.NamedScope.Accessibility">
            <summary>
            The access modifier for this scope
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.NamedScope.Id">
            <summary>
            The identifier for named scopes is the <see cref="P:ABB.SrcML.Data.NamedScope.Name"/>.
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.NamedScope.UnresolvedParentScopeInUse">
            <summary>
            This indicates which unresolved parent scope has been used to link this object with a parent object
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.NamedScope.ParentScopeCandidates">
            <summary>
            Collection of possible parent scope candidates
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.NamedScope.Name">
            <summary>
            The name of this scope
            </summary>
        </member>
        <member name="T:ABB.SrcML.Data.NameHelper">
            <summary>
            <para>NameHelper provides a collection of static methods that aid in parsing elements of with a node type of <see cref="F:ABB.SrcML.SRC.Name"/>.</para>
            <para>The functions are targetted at helping to parse the common srcML idiom of nesting <see cref="F:ABB.SrcML.SRC.Name"/> elements within other <see cref="F:ABB.SrcML.SRC.Name">name elements.</see></para>
            </summary>
        </member>
        <member name="M:ABB.SrcML.Data.NameHelper.GetNameElementsFromName(System.Xml.Linq.XElement)">
            <summary>
            This helper function returns all of the names from a name element. If a name element has no children, it just yields the name element back.
            However, if the name element has child elements, it yields all of the child name elements.
            </summary>
            <param name="nameElement">The name element</param>
            <returns>An enumerable of either all the child names, or the root if there are none.</returns>
        </member>
        <member name="M:ABB.SrcML.Data.NameHelper.GetLastName(System.Xml.Linq.XElement)">
            <summary>
            Gets the string value for the <see cref="M:ABB.SrcML.Data.NameHelper.GetLastNameElement(System.Xml.Linq.XElement)">last name element</see> of <paramref name="nameElement"/>
            </summary>
            <param name="nameElement">The name element</param>
            <returns>the string value for the last name in <paramref name="nameElement"/></returns>
        </member>
        <member name="M:ABB.SrcML.Data.NameHelper.GetLastNameElement(System.Xml.Linq.XElement)">
            <summary>
            Gets the last name from <paramref name="nameElement"/>. If <paramref name="nameElement"/> has no children of type <see cref="F:ABB.SrcML.SRC.Name"/>, it just returns <paramref name="nameElement"/>.
            </summary>
            <param name="nameElement">The name element</param>
            <returns>The last <see cref="F:ABB.SrcML.SRC.Name">name element</see> in <paramref name="nameElement"/>. If there are none, it returns <paramref name="nameElement"/></returns>
        </member>
        <member name="M:ABB.SrcML.Data.NameHelper.GetNamesExceptLast(System.Xml.Linq.XElement)">
            <summary>
            Gets the string values for all of the name elements in <paramref name="nameElement"/> <see cref="M:ABB.SrcML.Data.NameHelper.GetNameElementsExceptLast(System.Xml.Linq.XElement)">except for the last one</see>.
            </summary>
            <param name="nameElement">The name element</param>
            <returns>An enumerable of strings of all the name elements in <paramref name="nameElement"/> except for the last one. If there are no child elements, it returns an empty enumerable.</returns>
        </member>
        <member name="M:ABB.SrcML.Data.NameHelper.GetNameElementsExceptLast(System.Xml.Linq.XElement)">
            <summary>
            Gets all of the name elements from <paramref name="nameElement"/>. If <paramref name="nameElement"/> has no children of type <see cref="F:ABB.SrcML.SRC.Name"/>, returns an empty enumerable.
            </summary>
            <param name="nameElement">The name element</param>
            <returns>An enumerable of <see cref="F:ABB.SrcML.SRC.Name">name elements</see> in <paramref name="nameElement"/> except for the <see cref="M:ABB.SrcML.Data.NameHelper.GetLastNameElement(System.Xml.Linq.XElement)">last one</see></returns>
        </member>
        <member name="T:ABB.SrcML.Data.NamedScopeUse">
            <summary>
            The NamedScopeUse class represents a use of a named scope. It can create a
            <see cref="T:ABB.SrcML.Data.NamedScope"/> based on itself by calling
            <see cref="M:ABB.SrcML.Data.NamedScopeUse.CreateScope"/>.
            </summary>
        </member>
        <member name="M:ABB.SrcML.Data.NamedScopeUse.CreateScope">
            <summary>
            Creates a <see cref="T:ABB.SrcML.Data.NamedScope"/> object from this use (along with all of its
            descendants based on <see cref="P:ABB.SrcML.Data.NamedScopeUse.ChildScopeUse"/>).
            </summary>
            <returns>A new named scope based on this use</returns>
        </member>
        <member name="M:ABB.SrcML.Data.NamedScopeUse.FindMatches">
            <summary>
            Find named scopes that match this named scope use.
            </summary>
            <returns>An enumerable of named scopes with the same name as this use</returns>
        </member>
        <member name="M:ABB.SrcML.Data.NamedScopeUse.GetFullName">
            <summary>
            Constructs the full name for this named scope use by combining this scope with all of
            its <see cref="P:ABB.SrcML.Data.NamedScopeUse.ChildScopeUse">children</see>
            </summary>
            <returns>The full name</returns>
        </member>
        <member name="M:ABB.SrcML.Data.NamedScopeUse.Matches(ABB.SrcML.Data.NamedScope)">
            <summary>
            Returns true if this scope matches
            <paramref name="definition"/></summary>
            <param name="definition">The scope to check</param>
            <returns>True if this and definition have the same name</returns>
        </member>
        <member name="M:ABB.SrcML.Data.NamedScopeUse.ToString">
            <summary>
            Returns a string representation of this object.
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.NamedScopeUse.ChildScopeUse">
            <summary>
            The child of this scope
            </summary>
        </member>
        <member name="T:ABB.SrcML.Data.NamespaceUse">
            <summary>
            Represents the use of a namespace. This is primarily used in <see cref="T:ABB.SrcML.Data.Alias"/> objects
            </summary>
        </member>
        <member name="M:ABB.SrcML.Data.NamespaceUse.CreateScope">
            <summary>
            Creates a <see cref="T:ABB.SrcML.Data.NamespaceDefinition"/> object from this use (along with all of its descendants based on <see cref="P:ABB.SrcML.Data.NamedScopeUse.ChildScopeUse"/>).
            </summary>
            <returns>A new namespace definition based on this use</returns>
        </member>
        <member name="T:ABB.SrcML.Data.ParameterDeclaration">
            <summary>
            Represents a parameter declaration in a method.
            </summary>
        </member>
        <member name="T:ABB.SrcML.Data.VariableDeclaration">
            <summary>
            Represents a variable declaration
            </summary>
        </member>
        <member name="M:ABB.SrcML.Data.VariableDeclaration.ToString">
            <summary>
            Returns a string representation of this object.
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.VariableDeclaration.Accessibility">
            <summary>
            The access modifier assigned to this type
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.VariableDeclaration.Location">
            <summary>
            The location of this declaration in both the original source file and in XML.
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.VariableDeclaration.Name">
            <summary>
            The name of the variable
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.VariableDeclaration.Scope">
            <summary>
            The scope where this variable is declared
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.VariableDeclaration.VariableType">
            <summary>
            Description of the type for this variable
            </summary>
        </member>
        <member name="M:ABB.SrcML.Data.ParameterDeclaration.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:ABB.SrcML.Data.ParameterDeclaration.ToString">
            <summary>
            Returns a string representation of this object.
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.ParameterDeclaration.HasDefaultValue">
            <summary>
            Indicates whether or not there is a default value for this method parameter
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.ParameterDeclaration.Location">
            <summary>
            The primary location for this parameter
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.ParameterDeclaration.Locations">
            <summary>
            The locations where this parameter is declared. There can be more than one in the case
            of C/C++ where both the method prototype and definition declare the parameter.
            </summary>
        </member>
        <member name="T:ABB.SrcML.Data.ParserContext">
            <summary>
            Parser context objects store the current state of the <see cref="M:ABB.SrcML.Data.AbstractCodeParser.ParseElement(System.Xml.Linq.XElement,ABB.SrcML.Data.ParserContext)"/> method.
            </summary>
        </member>
        <member name="M:ABB.SrcML.Data.ParserContext.#ctor">
            <summary>
            Creates a new parser context
            </summary>
        </member>
        <member name="M:ABB.SrcML.Data.ParserContext.#ctor(System.Xml.Linq.XElement)">
            <summary>
            Creates a new parser context
            </summary>
            <param name="fileUnit">The file unit for this context</param>
        </member>
        <member name="M:ABB.SrcML.Data.ParserContext.CreateLocation(System.Xml.Linq.XElement,System.Boolean)">
            <summary>
            Creates a location object for the given <paramref name="element"/>.
            </summary>
            <param name="element">The element to create a location for</param>
            <param name="isReference">whether or not this is a reference location</param>
            <returns>The new location object. The <see cref="P:ABB.SrcML.Data.SourceLocation.SourceFileName"/> will be set to <see cref="P:ABB.SrcML.Data.ParserContext.FileName"/></returns>
        </member>
        <member name="M:ABB.SrcML.Data.ParserContext.CreateLocation(System.Xml.Linq.XElement)">
            <summary>
            Creates a location object for the given <paramref name="element"/>.
            </summary>
            <param name="element">The element to create a location for</param>
            <returns>The new location object. The <see cref="P:ABB.SrcML.Data.SourceLocation.SourceFileName"/> will be set to <see cref="P:ABB.SrcML.Data.ParserContext.FileName"/></returns>
        </member>
        <member name="M:ABB.SrcML.Data.ParserContext.Pop">
            <summary>
            Removes the most recent scope from the scope stack and returns it. If intermediate scopes were inserted, it calls <see cref="M:ABB.SrcML.Data.ParserContext.RevertToNextParent"/>.
            </summary>
            <returns>the most recent scope.</returns>
        </member>
        <member name="M:ABB.SrcML.Data.ParserContext.Push(ABB.SrcML.Data.Scope)">
            <summary>
            adds <paramref name="scope"/> to this scope stack. This simply calls <see cref="M:ABB.SrcML.Data.ParserContext.Push(ABB.SrcML.Data.Scope,ABB.SrcML.Data.Scope)"/> with both arguments set to <paramref name="scope"/>
            </summary>
            <param name="scope">the scope to add.</param>
        </member>
        <member name="M:ABB.SrcML.Data.ParserContext.Push(ABB.SrcML.Data.Scope,ABB.SrcML.Data.Scope)">
            <summary>
            Adds <paramref name="scope"/> and <paramref name="parent">it's parent</paramref>. If <see cref="P:ABB.SrcML.Data.ParserContext.CurrentParentScope"/> is equal to <paramref name="parent"/>
            then parent is not added.
            </summary>
            <param name="scope"></param>
            <param name="parent"></param>
        </member>
        <member name="M:ABB.SrcML.Data.ParserContext.RevertToNextParent">
            <summary>
            Removes scopes until <c>CurrentScope == CurrentParentScope</c>. As each scope is removed, it is added as a child to its predecessor.
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.ParserContext.Aliases">
            <summary>
            The aliases for this context. This should be set by a call to <see cref="M:ABB.SrcML.Data.AbstractCodeParser.ParseUnitElement(System.Xml.Linq.XElement,ABB.SrcML.Data.ParserContext)"/>.
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.ParserContext.FileName">
            <summary>
            The file name from <see cref="P:ABB.SrcML.Data.ParserContext.FileUnit"/>
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.ParserContext.FileUnit">
            <summary>
            The file unit for this context. This should be set by a call to <see cref="M:ABB.SrcML.Data.AbstractCodeParser.ParseUnitElement(System.Xml.Linq.XElement,ABB.SrcML.Data.ParserContext)"/>.
            Alternatively, this can be set manually for calls to other Parse methods in <see cref="T:ABB.SrcML.Data.AbstractCodeParser"/>.
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.ParserContext.ParentScopeStack">
            <summary>
            the parent scope stack stores the parent of the scope being parsed. This is only used in specific cases such as the following C# example:
            <code language="C#">
            namespace A.B.C { }
            </code>
            In this example, we want the tree to be <c>A-&gt;B-&gt;C</c>. What <see cref="M:ABB.SrcML.Data.AbstractCodeParser.ParseNamespaceElement(System.Xml.Linq.XElement,ABB.SrcML.Data.ParserContext)"/> does
            in this case is create three namespaces: <c>A</c>, <c>B</c>, and <c>C</c> and puts them all on <see cref="P:ABB.SrcML.Data.ParserContext.ScopeStack"/>. Because we have created
            three elements, we need a way to track how many need to be popped off. the <c>A</c> namespace will be put placed on <see cref="P:ABB.SrcML.Data.ParserContext.ParentScopeStack"/>.
            <see cref="M:ABB.SrcML.Data.AbstractCodeParser.ParseElement(System.Xml.Linq.XElement,ABB.SrcML.Data.ParserContext)"/> will see that ParentScopeStack and <see cref="P:ABB.SrcML.Data.ParserContext.ScopeStack"/> are not equal and 
            it will <see cref="M:System.Collections.Stack.Pop"/> elements off until they are.
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.ParserContext.ScopeStack">
            <summary>
            The scope stack stores all of the scopes being parsed. When <see cref="M:ABB.SrcML.Data.AbstractCodeParser.ParseElement(System.Xml.Linq.XElement,ABB.SrcML.Data.ParserContext)"/>
            creates a scope it pushes it onto the stack. Once it has finished creating the scope (including calling
            <see cref="M:ABB.SrcML.Data.AbstractCodeParser.ParseElement(System.Xml.Linq.XElement,ABB.SrcML.Data.ParserContext)"/> on all of its children), it removes it from the stack.
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.ParserContext.CurrentParentScope">
            <summary>
            The current scope on <see cref="P:ABB.SrcML.Data.ParserContext.ParentScopeStack"/>. If the stack is empty, it returns null.
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.ParserContext.CurrentScope">
            <summary>
            The current scope on <see cref="P:ABB.SrcML.Data.ParserContext.ScopeStack"/>. If the stack is empty, it returns null.
            </summary>
        </member>
        <member name="T:ABB.SrcML.Data.SourceLocation">
            <summary>
            Source locations indicate where in the original source code a <see cref="T:ABB.SrcML.Data.Scope"/> is located
            It stores the file name, line number, &amp; startingPosition
            </summary>
        </member>
        <member name="M:ABB.SrcML.Data.SourceLocation.#ctor">
            <summary>
            Creates a new empty SourceLocation
            </summary>
        </member>
        <member name="M:ABB.SrcML.Data.SourceLocation.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
            Creates a new source location object
            </summary>
            <param name="fileName">The file name</param>
            <param name="startingLineNumber">The starting line number.</param>
            <param name="startingColumnNumber">The starting column within <paramref name="startingLineNumber"/></param>
        </member>
        <member name="M:ABB.SrcML.Data.SourceLocation.#ctor(System.String,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new source location object
            </summary>
            <param name="fileName">The filename</param>
            <param name="startingLineNumber">the starting line number</param>
            <param name="startingPosition">The starting position within <paramref name="startingLineNumber"/></param>
            <param name="endingLineNumber">the ending line number</param>
            <param name="endingPosition">The ending position with <paramref name="endingLineNumber"/></param>
        </member>
        <member name="M:ABB.SrcML.Data.SourceLocation.Contains(ABB.SrcML.Data.SourceLocation)">
            <summary>
            Determines whether the given source location occurs within this location.
            </summary>
            <param name="otherLoc">The SourceLocation to test</param>
            <returns>True if this location subsumes the given location, False otherwise.</returns>
        </member>
        <member name="M:ABB.SrcML.Data.SourceLocation.ToString">
            <summary>
            Returns a string representation of the SourceLocation.
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.SourceLocation.SourceFileName">
            <summary>
            The file name for this location
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.SourceLocation.StartingLineNumber">
            <summary>
            The starting line number for this location
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.SourceLocation.StartingColumnNumber">
            <summary>
            The starting position within the line for this location
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.SourceLocation.EndingLineNumber">
            <summary>
            The ending line number for this location -- this is the starting line number of this element's sibling.
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.SourceLocation.EndingColumnNumber">
            <summary>
            The ending column number for this location -- this is the starting starting position of this element's sibling.
            </summary>
        </member>
        <member name="T:ABB.SrcML.Data.DataRepository">
             <summary>
             The data archive is an incrementally updating data container.
             </summary>
             <example>
             <code> var sourceFolder = new FileSystemSourceFolder("path to folder"); var archive = new
             SrcMLArchive(sourceFolder);
            
             // this should generate a data archive for the given srcML archive // when we start
             serializing data, we should consider how the location of the data can be stored in the srcmL
             archive // calling "DataRepository" on a srcML archive that already has data should
             transparently load the existing data DataRepository data = new DataRepository(archive);
            
             // testDeclaration is some declaration within archive var testDeclaration = new
             XElement(SRC.Declaration, "test data");
            
             // The TypeUse object represents the context that the type is being used in TypeUse
             typeUseForDeclaration = new TypeUse(testDeclaration); TypeDefinition typeInfo =
             data.ResolveType(typeUseForDeclaration);
            
             // one of the thing we should be able to do is get the original XML. Behind the scenes, this
             relies on using XPath queries // generated by Extensions.GetXPath() XElement typeXml =
             typeInfo.GetXElement(); TypeUse parentType = typeInfo.ParentTypes.First(); XElement
             parentXml = data.ResolveType(parentType).GetXElement(); </code>
             </example>
        </member>
        <member name="M:ABB.SrcML.Data.DataRepository.#ctor(ABB.SrcML.ISrcMLArchive)">
            <summary>
            Create a data archive for the given srcML archive. It will subscribe to the
            <see cref="!:AbstractArchive.FileChanged"/> event.
            </summary>
            <param name="archive">The archive to monitor for changes.</param>
        </member>
        <member name="M:ABB.SrcML.Data.DataRepository.#ctor(System.String)">
            <summary>
            Create a data archive with data stored in the given
            <paramref name="fileName">binary file</paramref> .
            </summary>
            <param name="fileName">The binary file the data archive is stored in</param>
        </member>
        <member name="M:ABB.SrcML.Data.DataRepository.#ctor(ABB.SrcML.ISrcMLArchive,System.String)">
            <summary>
            Create a data archive for the given srcML archive and binary file. It will load data
            from the binary archive and then subscribe to the srcML archive.
            </summary>
            <param name="archive">The srcML archive to monitor for changes. If null, no archive
            monitoring will be done.</param>
            <param name="fileName">The file to read data from. If null, no previously saved data
            will be loaded.</param>
        </member>
        <member name="M:ABB.SrcML.Data.DataRepository.AddFile(System.String)">
            <summary>
            Adds the given file to the data archive.
            </summary>
            <param name="sourceFile">The path of the file to add.</param>
        </member>
        <member name="M:ABB.SrcML.Data.DataRepository.AddFile(System.Xml.Linq.XElement)">
            <summary>
            Adds the given file to the data archive.
            </summary>
            <param name="fileUnitElement">The <see cref="F:ABB.SrcML.SRC.Unit"/> XElement for the file to
            add.</param>
        </member>
        <member name="M:ABB.SrcML.Data.DataRepository.Clear">
            <summary>
            Removes any data from the archive.
            </summary>
        </member>
        <member name="M:ABB.SrcML.Data.DataRepository.FindMethodCalls(ABB.SrcML.Data.SourceLocation)">
            <summary>
            Returns the method calls at the given source location. These are sorted with the calls
            closest to the location appearing first.
            </summary>
            <param name="loc">The source location to search for.</param>
            <returns>A collection of the method calls at the given location.</returns>
        </member>
        <member name="M:ABB.SrcML.Data.DataRepository.FindMethodCalls(System.Xml.Linq.XElement)">
            <summary>
            Returns the method calls surrounding the given srcML element. These are sorted with the
            calls closest to the element appearing first.
            </summary>
            <param name="element">The XElement to search for.</param>
            <returns>A collection of the method calls at the given element.</returns>
        </member>
        <member name="M:ABB.SrcML.Data.DataRepository.FindMethodCalls(System.String)">
            <summary>
            Returns the method calls at the given source location. These are sorted with the calls
            closest to the location appearing first.
            </summary>
            <param name="xpath">The path to search for.</param>
            <returns>A collection of the method calls at the given path.</returns>
        </member>
        <member name="M:ABB.SrcML.Data.DataRepository.FindScope(ABB.SrcML.Data.SourceLocation)">
            <summary>
            Finds the innermost scope that contains the given source location.
            </summary>
            <param name="loc">The source location to search for.</param>
            <returns>The innermost scope containing the location, or null if it is not
            found.</returns>
        </member>
        <member name="M:ABB.SrcML.Data.DataRepository.FindScope(System.Xml.Linq.XElement)">
            <summary>
            Finds the innermost scope that contains the given element.
            </summary>
            <param name="element">The element to search for.</param>
            <returns>The innermost scope containing the element, or null if it is not
            found.</returns>
        </member>
        <member name="M:ABB.SrcML.Data.DataRepository.FindScope(System.String)">
            <summary>
            Finds the innermost scope that contains the given XPath.
            </summary>
            <param name="xpath">The XPath to search for.</param>
            <returns>The innermost scope containing the XPath, or null if it is not found.</returns>
        </member>
        <member name="M:ABB.SrcML.Data.DataRepository.RemoveFile(System.String)">
            <summary>
            Removes the given file from the data archive
            </summary>
            <param name="sourceFile">The path of the file to remove.</param>
        </member>
        <member name="M:ABB.SrcML.Data.DataRepository.Save(System.String)">
            <summary>
            Serializes the archive to the specified file.
            </summary>
            <param name="fileName">The file to save the archive to.</param>
        </member>
        <member name="M:ABB.SrcML.Data.DataRepository.Save">
            <summary>
            Serializes the archive to <see cref="P:ABB.SrcML.Data.DataRepository.FileName"/>
            </summary>
        </member>
        <member name="M:ABB.SrcML.Data.DataRepository.Load(System.String)">
            <summary>
            Initializes the archive from the given file. This file must be a serialized
            DataRepository produced by DataRepository.Save().
            </summary>
            <param name="fileName">The file to load the archive from.</param>
            <exception cref="T:System.Runtime.Serialization.SerializationException">A problem occurred
            in deserialization. E.g. the serialized data is the wrong version.</exception>
        </member>
        <member name="P:ABB.SrcML.Data.DataRepository.Archive">
            <summary>
            The SrcMLArchive to extract the data from.
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.DataRepository.FileName">
            <summary>
            The file name to serialize to
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.DataRepository.GlobalScope">
            <summary>
            The top-level Scope for the data in the archive.
            </summary>
        </member>
        <member name="T:ABB.SrcML.Data.JavaCodeParser">
            <summary>
            Provides parsing facilities for the Java language
            </summary>
        </member>
        <member name="M:ABB.SrcML.Data.JavaCodeParser.#ctor">
            <summary>
            Creates a new java code parser object
            </summary>
        </member>
        <member name="M:ABB.SrcML.Data.JavaCodeParser.ParseUnitElement(System.Xml.Linq.XElement,ABB.SrcML.Data.ParserContext)">
            <summary>
            Parses a java file unit. This handles the "package" directive by calling <see cref="M:ABB.SrcML.Data.JavaCodeParser.ParseNamespaceElement(System.Xml.Linq.XElement,ABB.SrcML.Data.ParserContext)"/>
            </summary>
            <param name="unitElement">The file unit to parse</param>
            <param name="context">The parser context to place the global scope in</param>
        </member>
        <member name="M:ABB.SrcML.Data.JavaCodeParser.ParseNamespaceElement(System.Xml.Linq.XElement,ABB.SrcML.Data.ParserContext)">
            <summary>
            Parses a Java package directive
            </summary>
            <param name="namespaceElement">A file unit</param>
            <param name="context">The parser context</param>
        </member>
        <member name="M:ABB.SrcML.Data.JavaCodeParser.GetParentTypeUseElements(System.Xml.Linq.XElement)">
            <summary>
            Gets the parent type from a java type
            </summary>
            <param name="typeElement">The type element</param>
            <returns>The parent type elements for the class</returns>
        </member>
        <member name="M:ABB.SrcML.Data.JavaCodeParser.GetTypeForBooleanLiteral(System.String)">
            <summary>
            Parses a java boolean literal
            </summary>
            <param name="literalValue">the literal value</param>
            <returns>not implemented</returns>
        </member>
        <member name="M:ABB.SrcML.Data.JavaCodeParser.GetTypeForCharacterLiteral(System.String)">
            <summary>
            Parses a java character literal
            </summary>
            <param name="literalValue">the literal value</param>
            <returns>not implemented</returns>
        </member>
        <member name="M:ABB.SrcML.Data.JavaCodeParser.GetTypeForNumberLiteral(System.String)">
            <summary>
            Parses a java number literal
            </summary>
            <param name="literalValue">the literal value</param>
            <returns>not implemented</returns>
        </member>
        <member name="M:ABB.SrcML.Data.JavaCodeParser.GetTypeForStringLiteral(System.String)">
            <summary>
            Parses a java string
            </summary>
            <param name="literalValue">the literal value</param>
            <returns>Not implemented</returns>
        </member>
        <member name="M:ABB.SrcML.Data.JavaCodeParser.AliasIsNamespaceImport(System.Xml.Linq.XElement)">
            <summary>
            Checks if this java import statement is a wild card (<c>import java.lang.*</c>) or for a specific class (<c>import java.lang.String</c>)
            </summary>
            <param name="aliasStatement">The alias statement to check. Must be of type <see cref="P:ABB.SrcML.Data.AbstractCodeParser.AliasElementName"/></param>
            <returns>True if this import statement ends with an asterisk; false otherwise</returns>
        </member>
        <member name="M:ABB.SrcML.Data.JavaCodeParser.GetNamesFromAlias(System.Xml.Linq.XElement)">
            <summary>
            Gets all of the names for this alias
            </summary>
            <param name="aliasStatement">The alias statement. Must be of type <see cref="P:ABB.SrcML.Data.AbstractCodeParser.AliasElementName"/></param>
            <returns>An enumerable of all the <see cref="F:ABB.SrcML.SRC.Name">name elements</see> for this statement</returns>
        </member>
        <member name="P:ABB.SrcML.Data.JavaCodeParser.ParserLanguage">
            <summary>
            Returns <c>Language.Java</c>
            </summary>
        </member>
        <member name="T:ABB.SrcML.Data.MethodDefinition">
            <summary>
            A method definition object.
            </summary>
        </member>
        <member name="M:ABB.SrcML.Data.MethodDefinition.#ctor">
            <summary>
            Creates a new method definition object
            </summary>
        </member>
        <member name="M:ABB.SrcML.Data.MethodDefinition.#ctor(ABB.SrcML.Data.MethodDefinition)">
            <summary>
            Copy constructor
            </summary>
            <param name="otherDefinition">The scope to copy from</param>
        </member>
        <member name="M:ABB.SrcML.Data.MethodDefinition.AddMethodParameter(ABB.SrcML.Data.ParameterDeclaration)">
            <summary>
            Adds a method parameter to this method
            </summary>
            <param name="parameter">The parameter to add</param>
        </member>
        <member name="M:ABB.SrcML.Data.MethodDefinition.AddMethodParameters(System.Collections.Generic.IEnumerable{ABB.SrcML.Data.ParameterDeclaration})">
            <summary>
            Adds an enumerable of method parameters to this method.
            </summary>
            <param name="parameters">The parameters to add</param>
        </member>
        <member name="M:ABB.SrcML.Data.MethodDefinition.GetCallsTo(ABB.SrcML.Data.MethodDefinition)">
            <summary>
            Gets all the method calls in this method to <paramref name="callee"/>. This method searches 
            this method and all of its <see cref="P:ABB.SrcML.Data.Scope.ChildScopes"/>.
            </summary>
            <param name="callee">The method to find calls for.</param>
            <returns>All of the method calls to <paramref name="callee"/> in this method.</returns>
        </member>
        <member name="M:ABB.SrcML.Data.MethodDefinition.ContainsCallTo(ABB.SrcML.Data.MethodDefinition)">
            <summary>
            Checks to see if this method contains a call to <paramref name="callee"/>.
            </summary>
            <param name="callee">The method to look for calls to</param>
            <returns>True if this method contains any <see cref="M:ABB.SrcML.Data.MethodDefinition.GetCallsTo(ABB.SrcML.Data.MethodDefinition)">calls to</see> <paramref name="callee"/></returns>.
        </member>
        <member name="M:ABB.SrcML.Data.MethodDefinition.Merge(ABB.SrcML.Data.NamedScope)">
            <summary>
            Merges this method definition with <paramref name="otherScope"/>. This happens when <c>otherScope.CanBeMergedInto(this)</c> evaluates to true.
            </summary>
            <param name="otherScope">the scope to merge with</param>
            <returns>a new method definition from this and otherScope, or null if they couldn't be merged.</returns>
        </member>
        <member name="M:ABB.SrcML.Data.MethodDefinition.CanBeMergedInto(ABB.SrcML.Data.MethodDefinition)">
            <summary>
            Returns true if both this and <paramref name="otherScope"/> have the same name.
            </summary>
            <param name="otherScope">The scope to test</param>
            <returns>true if they are the same method; false otherwise.</returns>
            TODO implement better method merging
        </member>
        <member name="M:ABB.SrcML.Data.MethodDefinition.CanBeMergedInto(ABB.SrcML.Data.NamedScope)">
            <summary>
            Casts <paramref name="otherScope"/> to a <see cref="T:ABB.SrcML.Data.MethodDefinition"/> and calls <see cref="M:ABB.SrcML.Data.MethodDefinition.CanBeMergedInto(ABB.SrcML.Data.MethodDefinition)"/>
            </summary>
            <param name="otherScope">The scope to test</param>
            <returns>true if <see cref="M:ABB.SrcML.Data.MethodDefinition.CanBeMergedInto(ABB.SrcML.Data.MethodDefinition)"/> evaluates to true.</returns>
        </member>
        <member name="M:ABB.SrcML.Data.MethodDefinition.AddFrom(ABB.SrcML.Data.Scope)">
            <summary>
            The AddFrom function adds all of the declarations and children from <paramref name="otherScope"/> to this scope
            </summary>
            <param name="otherScope">The scope to add data from</param>
            <returns>the new scope</returns>
        </member>
        <member name="M:ABB.SrcML.Data.MethodDefinition.RemoveFile(System.String)">
            <summary>
            Removes any program elements defined in the given file.
            If the scope is defined entirely within the given file, then it removes itself from its parent.
            </summary>
            <param name="fileName">The file to remove.</param>
            <returns>A collection of any unresolved scopes that result from removing the file. The caller is responsible for re-resolving these as appropriate.</returns>
        </member>
        <member name="M:ABB.SrcML.Data.MethodDefinition.ToString">
            <summary>Returns a string representation of this object.</summary>
        </member>
        <member name="P:ABB.SrcML.Data.MethodDefinition.IsConstructor">
            <summary>
            True if this is a constructor; false otherwise
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.MethodDefinition.IsDestructor">
            <summary>
            True if this is a destructor; false otherwise
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.MethodDefinition.ReturnType">
            <summary>
            The return type for this method
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.MethodDefinition.Parameters">
            <summary>
            The parameters for this method.
            </summary>
        </member>
        <member name="T:ABB.SrcML.Data.NamespaceDefinition">
            <summary>
            Represents a namespace definition
            </summary>
        </member>
        <member name="M:ABB.SrcML.Data.NamespaceDefinition.#ctor">
            <summary>
            Creates a new namespace definition object
            </summary>
        </member>
        <member name="M:ABB.SrcML.Data.NamespaceDefinition.#ctor(ABB.SrcML.Data.NamespaceDefinition)">
            <summary>
            Copy constructor
            </summary>
            <param name="otherDefinition">The scope to copy from</param>
        </member>
        <member name="M:ABB.SrcML.Data.NamespaceDefinition.MakeQualifiedName(System.String)">
            <summary>
            Returns the fully qualified name for the given type
            </summary>
            <param name="name">A name</param>
            <returns>the fully qualified name (made from this namespace definition and the given name)</returns>
        </member>
        <member name="M:ABB.SrcML.Data.NamespaceDefinition.Merge(ABB.SrcML.Data.NamedScope)">
            <summary>
            Merges this namespace definition with <paramref name="otherScope"/>. This happens when <c>otherScope.CanBeMergedInto(this)</c> evaluates to true.
            </summary>
            <param name="otherScope">the scope to merge with</param>
            <returns>a new namespace definition from this and otherScope, or null if they couldn't be merged.</returns>
        </member>
        <member name="M:ABB.SrcML.Data.NamespaceDefinition.CanBeMergedInto(ABB.SrcML.Data.NamespaceDefinition)">
            <summary>
            Returns true if both this and <paramref name="otherScope"/> have the same name.
            </summary>
            <param name="otherScope">The scope to test</param>
            <returns>true if they are the same namespace; false otherwise.</returns>
        </member>
        <member name="M:ABB.SrcML.Data.NamespaceDefinition.CanBeMergedInto(ABB.SrcML.Data.NamedScope)">
            <summary>
            Casts <paramref name="otherScope"/> to a <see cref="T:ABB.SrcML.Data.NamespaceDefinition"/> and calls <see cref="M:ABB.SrcML.Data.NamespaceDefinition.CanBeMergedInto(ABB.SrcML.Data.NamespaceDefinition)"/>
            </summary>
            <param name="otherScope">The scope to test</param>
            <returns>true if <see cref="M:ABB.SrcML.Data.NamespaceDefinition.CanBeMergedInto(ABB.SrcML.Data.NamespaceDefinition)"/> evaluates to true.</returns>
        </member>
        <member name="M:ABB.SrcML.Data.NamespaceDefinition.RemoveFile(System.String)">
            <summary>
            Removes any program elements defined in the given file.
            If the scope is defined entirely within the given file, then it removes itself from its parent.
            </summary>
            <param name="fileName">The file to remove.</param>
            <returns>A collection of any unresolved scopes that result from removing the file. The caller is responsible for re-resolving these as appropriate.</returns>
        </member>
        <member name="M:ABB.SrcML.Data.NamespaceDefinition.ToString">
            <summary>
            Creates a string representation of this namespace
            </summary>
            <returns>A string that describes this namespace definition</returns>
        </member>
        <member name="P:ABB.SrcML.Data.NamespaceDefinition.IsAnonymous">
            <summary>
            Returns true if this is an anonymous namespace
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.NamespaceDefinition.IsGlobal">
            <summary>
            <para>Returns true if this namespace represents the global namespace</para>
            <para>A namespace is global if the <see cref="P:ABB.SrcML.Data.NamedScope.Name"/> is <c>String.Empty</c></para>
            </summary>
        </member>
        <member name="T:ABB.SrcML.Data.CPlusPlusCodeParser">
            <summary>
            Provides parsing facilities for the C++ language
            </summary>
        </member>
        <member name="M:ABB.SrcML.Data.CPlusPlusCodeParser.#ctor">
            <summary>
            Creates a new C++ code parser object
            </summary>
        </member>
        <member name="M:ABB.SrcML.Data.CPlusPlusCodeParser.ParseNamespaceElement(System.Xml.Linq.XElement,ABB.SrcML.Data.ParserContext)">
            <summary>
            Creates a NamespaceDefinition object for the given namespace typeUseElement. This must be one of the typeUseElement types defined in NamespaceElementNames.
            </summary>
            <param name="namespaceElement">the namespace element</param>
            <param name="context">The parser context</param>
            <returns>a new NamespaceDefinition object</returns>
        </member>
        <member name="M:ABB.SrcML.Data.CPlusPlusCodeParser.ParseMethodElement(System.Xml.Linq.XElement,ABB.SrcML.Data.ParserContext)">
            <summary>
            Creates a method definition object from <paramref name="methodElement"/>. For C++, it looks for
            <code>int A::B::Foo(){ }</code> and adds "A-&gt;B" to <see cref="P:ABB.SrcML.Data.NamedScope.ParentScopeCandidates"/>
            </summary>
            <param name="methodElement">The method typeUseElement</param>
            <param name="context">The parser context</param>
            <returns>the method definition object for <paramref name="methodElement"/></returns>
        </member>
        <member name="M:ABB.SrcML.Data.CPlusPlusCodeParser.GetNameForMethod(System.Xml.Linq.XElement)">
            <summary>
            Gets the name for a method. This is the unqualified name, not any class names that might be prepended to it.
            </summary>
            <param name="methodElement">The method typeUseElement</param>
            <returns>a string with the method name</returns>
        </member>
        <member name="M:ABB.SrcML.Data.CPlusPlusCodeParser.GetAccessModifierForMethod(System.Xml.Linq.XElement)">
            <summary>
            Gets the access modifiers for this method. In C++, methods are contained within "specifier" blocks
            </summary>
            <param name="methodElement">The method typeUseElement</param>
            <returns>The access modifier for this method; if none, it returns <see cref="F:ABB.SrcML.Data.AccessModifier.None"/></returns>
        </member>
        <member name="M:ABB.SrcML.Data.CPlusPlusCodeParser.GetAccessModifierForType(System.Xml.Linq.XElement)">
            <summary>
            Gets the access modifier for this type. In C++, all types are public, so this always returns "public"
            </summary>
            <param name="typeElement">The type</param>
            <returns>the access modifier for this type.</returns>
        </member>
        <member name="M:ABB.SrcML.Data.CPlusPlusCodeParser.GetParentTypeUseElements(System.Xml.Linq.XElement)">
            <summary>
            Gets the parent types for this type. It parses the C++ ":" operator that appears in type definitions.
            </summary>
            <param name="typeElement">The type typeUseElement</param>
            <returns>A collection of type use elements that represent the parent classes</returns>
        </member>
        <member name="M:ABB.SrcML.Data.CPlusPlusCodeParser.AliasIsNamespaceImport(System.Xml.Linq.XElement)">
            <summary>
            Checks if this alias statement represents a namespace import or something more specific (such as a method or class alias).
            In C++, namespace aliases contain the "namespace" keyword (for instance, <c>using namespace std;</c>).
            </summary>
            <param name="aliasStatement">The statement to parse. Should be of type <see cref="P:ABB.SrcML.Data.AbstractCodeParser.AliasElementName"/></param>
            <returns>True if this is a namespace import; false otherwise</returns>
        </member>
        <member name="M:ABB.SrcML.Data.CPlusPlusCodeParser.GetChildContainersFromType(System.Xml.Linq.XElement)">
            <summary>
            Gets the child containers for a C++ type typeUseElement. This iterates over the public, private, and protected blocks that appear in C++ classes in srcML.
            </summary>
            <param name="container">the type typeUseElement</param>
            <returns>the child elements of this C++ type</returns>
        </member>
        <member name="M:ABB.SrcML.Data.CPlusPlusCodeParser.GetDeclarationsFromTypeElement(System.Xml.Linq.XElement)">
            <summary>
            Gets the variables declared in this C++ type typeUseElement. This iterates over the public, private, and protected blocks that appear in C++ classes in srcML.
            </summary>
            <param name="container">the type typeUseElement</param>
            <returns>The decl elements for this type typeUseElement</returns>
        </member>
        <member name="M:ABB.SrcML.Data.CPlusPlusCodeParser.GetTypeForBooleanLiteral(System.String)">
            <summary>
            Parses a C++ boolean literal
            </summary>
            <param name="literalValue">The literal value</param>
            <returns>Returns "bool"</returns>
        </member>
        <member name="M:ABB.SrcML.Data.CPlusPlusCodeParser.GetTypeForCharacterLiteral(System.String)">
            <summary>
            Parses a C++ character literal
            </summary>
            <param name="literalValue">The literal value</param>
            <returns>Returns "char"</returns>
        </member>
        <member name="M:ABB.SrcML.Data.CPlusPlusCodeParser.GetTypeForNumberLiteral(System.String)">
            <summary>
            Parses a C++ number literal
            </summary>
            <param name="literalValue">The literal value</param>
            <returns>Uses <see href="http://www.cplusplus.com/doc/tutorial/constants/">C++ number rules</see> to determine the proper type</returns>
        </member>
        <member name="M:ABB.SrcML.Data.CPlusPlusCodeParser.GetTypeForStringLiteral(System.String)">
            <summary>
            Parses a C++ string literal
            </summary>
            <param name="literalValue">The literal value</param>
            <returns>Returns "char*"</returns>
        </member>
        <member name="M:ABB.SrcML.Data.CPlusPlusCodeParser.GetParametersFromMethodElement(System.Xml.Linq.XElement)">
            <summary>
            Checks if the method element has only one parameter "void" (which is really zero parameters in C/C++). If not, it just calls <see cref="M:ABB.SrcML.Data.AbstractCodeParser.GetParametersFromMethodElement(System.Xml.Linq.XElement)"/>
            </summary>
            <param name="method">The method to get parameter elements for</param>
            <returns>An enumerable of method parameter elements</returns>
        </member>
        <member name="P:ABB.SrcML.Data.CPlusPlusCodeParser.ParserLanguage">
            <summary>
            Returns <c>Language.CPlusPlus</c>
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.CPlusPlusCodeParser.SpecifierContainerNames">
            <summary>
            Returns the list of specifier containers (<see cref="F:ABB.SrcML.SRC.Private"/>, <see cref="F:ABB.SrcML.SRC.Protected"/>, and <see cref="F:ABB.SrcML.SRC.Public"/>
            </summary>
        </member>
        <member name="T:ABB.SrcML.Data.SrcMLLocation">
            <summary>
            Represents a location in a SrcML document. 
            This extends SourceLocation to include an XPath, and other relevant properties.
            </summary>
        </member>
        <member name="M:ABB.SrcML.Data.SrcMLLocation.#ctor(System.Xml.Linq.XElement,System.String)">
            <summary>
            Creates a new srcML location object
            </summary>
            <param name="element">The srcML element that this location refers to</param>
            <param name="fileName">The filename</param>
        </member>
        <member name="M:ABB.SrcML.Data.SrcMLLocation.#ctor(System.Xml.Linq.XElement,System.Xml.Linq.XElement)">
            <summary>
            Creates a new srcML location object based on the given <see cref="T:System.Xml.Linq.XElement">XML element</see> and <see cref="F:ABB.SrcML.SRC.Unit">file unit</see>
            </summary>
            <param name="element">The element (should contain <see cref="T:ABB.SrcML.POS"/> attributes</param>
            <param name="fileUnit">The file unit (must be a <see cref="F:ABB.SrcML.SRC.Unit"/>)</param>
        </member>
        <member name="M:ABB.SrcML.Data.SrcMLLocation.#ctor(System.Xml.Linq.XElement,System.Xml.Linq.XElement,System.Boolean)">
            <summary>
            Creates a new srcML location object
            </summary>
            <param name="element">The srcML element that this location refers to</param>
            <param name="fileUnit">The file unit that contains <paramref name="element"/></param>
            <param name="isReferenceLocation">true if this is a reference location; false otherwise</param>
        </member>
        <member name="M:ABB.SrcML.Data.SrcMLLocation.#ctor(System.Xml.Linq.XElement,System.String,System.Boolean)">
            <summary>
            Creates a new srcML location object
            </summary>
            <param name="element">The srcML element that this location refers to</param>
            <param name="fileName">The filename</param>
            <param name="isReferenceLocation">true if this is a reference location; false otherwise</param>
        </member>
        <member name="M:ABB.SrcML.Data.SrcMLLocation.Contains(ABB.SrcML.Data.SourceLocation)">
            <summary>
            Determines whether the given source location occurs within this location.
            This will be determined using the XPath, if set.
            </summary>
            <param name="otherLoc">The SourceLocation to test</param>
            <returns>True if this location subsumes the given location, False otherwise.</returns>
        </member>
        <member name="P:ABB.SrcML.Data.SrcMLLocation.XPath">
            <summary>
            The XPath query that identifies this scope
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.SrcMLLocation.IsReference">
            <summary>
            True if this location is a reference; false if it is a definition
            </summary>
        </member>
        <member name="T:ABB.SrcML.Data.TypeDefinition">
            <summary>
            Represents a type definition
            </summary>
        </member>
        <member name="M:ABB.SrcML.Data.TypeDefinition.#ctor">
            <summary>
            Creates a new type definition object
            </summary>
        </member>
        <member name="M:ABB.SrcML.Data.TypeDefinition.#ctor(ABB.SrcML.Data.TypeDefinition)">
            <summary>
            Copy constructor
            </summary>
            <param name="otherDefinition">The scope to copy from</param>
        </member>
        <member name="M:ABB.SrcML.Data.TypeDefinition.GetTypeForKeyword``1(ABB.SrcML.Data.AbstractUse{``0})">
            <summary>
            This handles the "base" keyword (C# only) and the "this" keyword. It searches for the
            appropriate type definition depending on the context of the
            </summary>
            <typeparam name="T">The use type</typeparam>
            <param name="use">The use to find the containing class for</param>
            <returns>The class referred to by the keyword</returns>
        </member>
        <member name="M:ABB.SrcML.Data.TypeDefinition.AddFrom(ABB.SrcML.Data.Scope)">
            <summary>
            The AddFrom function adds all of the declarations and children from
            <paramref name="otherScope"/>to this scope
            </summary>
            <param name="otherScope">The scope to add data from</param>
            <returns>the new scope</returns>
        </member>
        <member name="M:ABB.SrcML.Data.TypeDefinition.AddParentType(ABB.SrcML.Data.TypeUse)">
            <summary>
            Adds
            <paramref name="parentTypeUse"/>as a parent type for this type definition
            </summary>
            <param name="parentTypeUse">The parent type to add</param>
        </member>
        <member name="M:ABB.SrcML.Data.TypeDefinition.CanBeMergedInto(ABB.SrcML.Data.TypeDefinition)">
            <summary>
            Returns true if both this and
            <paramref name="otherScope"/>have the same name and are both partial.
            </summary>
            <param name="otherScope">The scope to test</param>
            <returns>true if they are the same class; false otherwise.</returns>
        </member>
        <member name="M:ABB.SrcML.Data.TypeDefinition.CanBeMergedInto(ABB.SrcML.Data.NamedScope)">
            <summary>
            Casts
            <paramref name="otherScope"/>to a <see cref="T:ABB.SrcML.Data.TypeDefinition"/> and calls
            <see cref="M:ABB.SrcML.Data.TypeDefinition.CanBeMergedInto(ABB.SrcML.Data.TypeDefinition)"/>
            </summary>
            <param name="otherScope">The scope to test</param>
            <returns>true if <see cref="M:ABB.SrcML.Data.TypeDefinition.CanBeMergedInto(ABB.SrcML.Data.TypeDefinition)"/> evaluates to
            true.</returns>
        </member>
        <member name="M:ABB.SrcML.Data.TypeDefinition.GetParentTypes">
            <summary>
            Resolves all of the parent type uses for this type definition
            </summary>
            <returns>Matching parent types for this type</returns>
        </member>
        <member name="M:ABB.SrcML.Data.TypeDefinition.GetParentTypesAndSelf">
            <summary>
            Returns this class followed by all of its parent classes (via a call to
            <see cref="M:ABB.SrcML.Data.TypeDefinition.GetParentTypes"/>
            </summary>
            <returns>An enumerable consisting of this object followed by the results of see
            cref="GetParentTypes()"/&gt;</returns>
        </member>
        <member name="M:ABB.SrcML.Data.TypeDefinition.Merge(ABB.SrcML.Data.NamedScope)">
            <summary>
            Merges this type definition with
            <paramref name="otherScope"/>. This happens when <c>otherScope.CanBeMergedInto(this)</c>
            evaluates to true.
            </summary>
            <param name="otherScope">the scope to merge with</param>
            <returns>a new type definition from this and otherScope, or null if they couldn't be
            merged</returns>
        </member>
        <member name="M:ABB.SrcML.Data.TypeDefinition.RemoveFile(System.String)">
            <summary>
            Removes any program elements defined in the given file. If the scope is defined entirely
            within the given file, then it removes itself from its parent.
            </summary>
            <param name="fileName">The file to remove.</param>
            <returns>A collection of any unresolved scopes that result from removing the file. The
            caller is responsible for re-resolving these as appropriate.</returns>
        </member>
        <member name="M:ABB.SrcML.Data.TypeDefinition.ToString">
            <summary>
            Creates a string representation for this type
            </summary>
            <returns>A string that describes this type</returns>
        </member>
        <member name="P:ABB.SrcML.Data.TypeDefinition.IsPartial">
            <summary>
            Partial if this is a partial class (used in C#)
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.TypeDefinition.Kind">
            <summary>
            The <see cref="T:ABB.SrcML.Data.TypeKind"/> of this type
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.TypeDefinition.ParentTypes">
            <summary>
            The parent types that this type inherits from
            </summary>
        </member>
        <member name="T:ABB.SrcML.Data.TypeKind">
            <summary>
            Enumerates the kinds of types encountered in the supported programming languages.
            </summary>
        </member>
        <member name="F:ABB.SrcML.Data.TypeKind.BuiltIn">
            <summary>Built-In type</summary>
        </member>
        <member name="F:ABB.SrcML.Data.TypeKind.Class">
            <summary>Class type</summary>
        </member>
        <member name="F:ABB.SrcML.Data.TypeKind.Struct">
            <summary>Struct type</summary>
        </member>
        <member name="F:ABB.SrcML.Data.TypeKind.Union">
            <summary>Union type</summary>
        </member>
        <member name="F:ABB.SrcML.Data.TypeKind.Interface">
            <summary>Interface type</summary>
        </member>
        <member name="F:ABB.SrcML.Data.TypeKind.Enumeration">
            <summary>Enumeration type</summary>
        </member>
        <member name="T:ABB.SrcML.Data.VariableScopeIterator">
            <summary>
            <para>The VariableScopeIterator returns an enumerable of a <see cref="T:ABB.SrcML.Data.Scope"/> and all of its descendants.</para>
            <para>It works by yielding the element, and then calling Visit on each of the child scopes.</para>
            </summary>
        </member>
        <member name="M:ABB.SrcML.Data.VariableScopeIterator.#ctor">
            <summary>
            Dummy constructor
            </summary>
        </member>
        <member name="M:ABB.SrcML.Data.VariableScopeIterator.VisitScope(ABB.SrcML.Data.Scope)">
            <summary>
            Visits all the nodes in the scope graph rooted at <paramref name="scope"/>
            </summary>
            <param name="scope">the root scope</param>
            <returns>An enumerable of all the scopes rooted at <paramref name="scope"/></returns>
        </member>
        <member name="M:ABB.SrcML.Data.VariableScopeIterator.Visit(ABB.SrcML.Data.Scope)">
            <summary>
            Convenience method for constructing the iterator and visiting the variable scope.
            </summary>
            <param name="scope">the root scope</param>
            <returns>An enumerable of all the scopes rooted at <paramref name="scope"/></returns>
        </member>
        <member name="T:ABB.SrcML.Data.VariableUse">
            <summary>
            The variable use class represents a use of a variable.
            </summary>
        </member>
        <member name="M:ABB.SrcML.Data.VariableUse.FindFirstMatchingType">
            <summary>
            Gets the first result from <see cref="M:ABB.SrcML.Data.VariableUse.FindMatchingTypes"/>
            </summary>
            <returns>The first matching variable type definition</returns>
        </member>
        <member name="M:ABB.SrcML.Data.VariableUse.FindMatches">
            <summary>
            Searches through the <see cref="P:ABB.SrcML.Data.Scope.DeclaredVariables"/> to see if any of them
            <see cref="M:ABB.SrcML.Data.VariableUse.Matches(ABB.SrcML.Data.VariableDeclaration)">matches</see>
            </summary>
            <returns>An enumerable of matching variable declarations.</returns>
        </member>
        <member name="M:ABB.SrcML.Data.VariableUse.FindMatchingTypes">
            <summary>
            Finds all of the matching type definitions for all of the variable declarations that
            match this variable use
            </summary>
            <returns>An enumerable of matching type definitions</returns>
        </member>
        <member name="M:ABB.SrcML.Data.VariableUse.Matches(ABB.SrcML.Data.VariableDeclaration)">
            <summary>
            Tests if this variable usage is a match for
            <paramref name="definition"/></summary>
            <param name="definition">The variable declaration to test</param>
            <returns>true if this matches the variable declaration; false otherwise</returns>
        </member>
        <member name="P:ABB.SrcML.Data.VariableUse.CallingObject">
            <summary>
            The calling object for a use is used when you have <c>a.b</c> -- this variable use would
            refer to <c>b</c> and the calling object would be <c>a</c>.
            </summary>
        </member>
        <member name="P:ABB.SrcML.Data.VariableUse.ParentScope">
            <summary>
            The scope that contains this variable use. If the parent scope is updated, then the
            parent scope of the calling object is also updated.
            </summary>
        </member>
        <member name="T:ABB.SrcML.Data.XNameMaps">
            <summary>
            This class houses a mapping of <see cref="T:System.Xml.Linq.XName"/> to <see cref="T:ABB.SrcML.Data.TypeKind"/>/
            </summary>
        </member>
        <member name="M:ABB.SrcML.Data.XNameMaps.GetKindForXElement(System.Xml.Linq.XElement)">
            <summary>
            gets the TypeKind for the given typeElement. The element must be of node type <see cref="F:ABB.SrcML.SRC.Struct"/>,
            <see cref="F:ABB.SrcML.SRC.Class"/>, <see cref="F:ABB.SrcML.SRC.Struct"/>, <see cref="F:ABB.SrcML.SRC.Union"/>,
            or <see cref="F:ABB.SrcML.SRC.Enum"/>
            </summary>
            <param name="typeElement">The type element</param>
            <returns>The kind of the type element</returns>
        </member>
    </members>
</doc>
